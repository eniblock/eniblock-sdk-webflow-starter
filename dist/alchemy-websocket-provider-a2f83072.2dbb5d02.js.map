{"mappings":"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","sources":["node_modules/alchemy-sdk/src/internal/websocket-backfiller.ts","node_modules/alchemy-sdk/src/api/alchemy-websocket-provider.ts","node_modules/sturdy-websocket/src/index.ts"],"sourcesContent":["import { AlchemyWebSocketProvider } from '../api/alchemy-websocket-provider';\nimport { fromHex, toHex } from '../api/util';\n\nexport interface BatchPart {\n  method: string;\n  params?: any;\n}\n\nexport interface NewHeadsEvent {\n  author: string;\n  difficulty: string;\n  extraData: string;\n  gasLimit: string;\n  gasUsed: string;\n  hash: string;\n  logsBloom: string;\n  miner: string;\n  mixHash: string;\n  nonce: string;\n  number: string;\n  parentHash: string;\n  receiptsRoot: string;\n  sealFields: string[];\n  sha3Uncles: string;\n  size: string;\n  stateRoot: string;\n  timestamp: string;\n  transactionsRoot: string;\n}\n\n/** The return type of eth_getBlocksByHash. */\nexport interface BlockHead extends NewHeadsEvent {\n  totalDifficulty: string;\n  transactions: any[];\n  uncles: string[];\n}\n\nexport interface LogsEvent {\n  address: string;\n  blockHash: string;\n  blockNumber: string;\n  data: string;\n  logIndex: string;\n  topics: string[];\n  transactionHash: string;\n  transactionIndex: string;\n  removed?: boolean;\n}\n\nexport interface LogsSubscriptionFilter {\n  address?: string | string[];\n  topics?: Array<string | string[] | null>;\n}\n\nexport interface GetLogsOptions extends LogsSubscriptionFilter {\n  fromBlock?: string;\n  toBlock?: string;\n}\n\ninterface CommonAncestor {\n  blockNumber: number;\n  logIndex: number;\n}\n\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n\n/**\n * The WebsocketBackfiller fetches events that were sent since a provided block\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\n * events that were transmitted while the websocket connection was down.\n *\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\n *\n * @internal\n */\nexport class WebsocketBackfiller {\n  // TODO: Use HTTP provider to do backfill.\n  private maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n  constructor(private readonly provider: AlchemyWebSocketProvider) {}\n\n  /**\n   * Runs backfill for `newHeads` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param previousHeads Previous head requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   * @returns A list of `newHeads` events that were sent since the last backfill.\n   */\n  async getNewHeadsBackfill(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n    fromBlockNumber: number\n  ): Promise<NewHeadsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous heads to fetch, return new heads since\n    // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n    if (previousHeads.length === 0) {\n      return this.getHeadEventsInRange(\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted event is too far back in the past, there's no need\n    // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n    // new heads.\n    const lastSeenBlockNumber = fromHex(\n      previousHeads[previousHeads.length - 1].number\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber <= minBlockNumber) {\n      return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n    }\n\n    // To capture all `newHeads` events, return all head events from the last\n    // seen block number to current + any of the previous heads that were re-orged.\n    const reorgHeads: NewHeadsEvent[] = await this.getReorgHeads(\n      isCancelled,\n      previousHeads\n    );\n    throwIfCancelled(isCancelled);\n    const intermediateHeads: NewHeadsEvent[] = await this.getHeadEventsInRange(\n      lastSeenBlockNumber + 1,\n      toBlockNumber + 1\n    );\n    throwIfCancelled(isCancelled);\n    return [...reorgHeads, ...intermediateHeads];\n  }\n\n  /**\n   * Runs backfill for `logs` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param filter The filter object that accompanies a logs subscription.\n   * @param previousLogs Previous log requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   */\n  async getLogsBackfill(\n    isCancelled: () => boolean,\n    filter: LogsSubscriptionFilter,\n    previousLogs: LogsEvent[],\n    fromBlockNumber: number\n  ): Promise<LogsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous logs to fetch, return new logs since\n    // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n    if (previousLogs.length === 0) {\n      return this.getLogsInRange(\n        filter,\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted log is too far back in the past, there's no need\n    // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n    // worth of logs.\n    const lastSeenBlockNumber = fromHex(\n      previousLogs[previousLogs.length - 1].blockNumber\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n    }\n\n    // Return all log events that have happened along with log events that have\n    // been removed due to a chain reorg.\n    const commonAncestor = await this.getCommonAncestor(\n      isCancelled,\n      previousLogs\n    );\n    throwIfCancelled(isCancelled);\n\n    // All previous logs with a block number greater than the common ancestor\n    // were part of a re-org, so mark them as such.\n    const removedLogs = previousLogs\n      .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\n      .map(log => ({ ...log, removed: true }));\n\n    // If no common ancestor was found, start backfill from the oldest log's\n    // block number.\n    const fromBlockInclusive =\n      commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\n        ? fromHex(previousLogs[0].blockNumber)\n        : commonAncestor.blockNumber;\n    let addedLogs = await this.getLogsInRange(\n      filter,\n      fromBlockInclusive,\n      toBlockNumber + 1\n    );\n\n    // De-dupe any logs that were already emitted.\n    addedLogs = addedLogs.filter(\n      log =>\n        log &&\n        (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\n          fromHex(log.logIndex) > commonAncestor.logIndex)\n    );\n\n    throwIfCancelled(isCancelled);\n    return [...removedLogs, ...addedLogs];\n  }\n\n  /**\n   * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\n   *\n   * @internal\n   */\n  setMaxBackfillBlock(newMax: number): void {\n    this.maxBackfillBlocks = newMax;\n  }\n\n  /**\n   * Gets the current block number as a number.\n   *\n   * @private\n   */\n  private async getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await this.provider.send('eth_blockNumber');\n    return fromHex(blockNumberHex);\n  }\n\n  /**\n   * Gets all `newHead` events in the provided range. Note that the returned\n   * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\n   * that were part of a re-org.\n   *\n   * @private\n   */\n  private async getHeadEventsInRange(\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<NewHeadsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const batchParts: BatchPart[] = [];\n    for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n      batchParts.push({\n        method: 'eth_getBlockByNumber',\n        params: [toHex(i), false]\n      });\n    }\n\n    // TODO: handle errors\n    const blockHeads = await this.provider.sendBatch(batchParts);\n    return blockHeads.map(toNewHeadsEvent);\n  }\n\n  /**\n   * Returns all heads that were part of a reorg event.\n   *\n   * @private\n   */\n  private async getReorgHeads(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[]\n  ): Promise<NewHeadsEvent[]> {\n    const result: NewHeadsEvent[] = [];\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    for (let i = previousHeads.length - 1; i >= 0; i--) {\n      const oldEvent = previousHeads[i];\n      const blockHead = await this.getBlockByNumber(fromHex(oldEvent.number));\n      throwIfCancelled(isCancelled);\n\n      // If the hashes match, then current head in the iteration was not re-orged.\n      if (oldEvent.hash === blockHead.hash) {\n        break;\n      }\n\n      result.push(toNewHeadsEvent(blockHead));\n    }\n    return result.reverse();\n  }\n\n  /**\n   * Simple wrapper around `eth_getBlockByNumber` that returns the complete\n   * block information for the provided block number.\n   *\n   * @private\n   */\n  private async getBlockByNumber(blockNumber: number): Promise<BlockHead> {\n    return this.provider.send('eth_getBlockByNumber', [\n      toHex(blockNumber),\n      false\n    ]);\n  }\n\n  /**\n   * Given a list of previous log events, finds the common block number from the\n   * logs that matches the block head.\n   *\n   * This can be used to identify which logs are part of a re-org.\n   *\n   * Returns 1 less than the oldest log's block number if no common ancestor was found.\n   *\n   * @private\n   */\n  private async getCommonAncestor(\n    isCancelled: () => boolean,\n    previousLogs: LogsEvent[]\n  ): Promise<CommonAncestor> {\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    let blockHead = await this.getBlockByNumber(\n      fromHex(previousLogs[previousLogs.length - 1].blockNumber)\n    );\n    throwIfCancelled(isCancelled);\n    for (let i = previousLogs.length - 1; i >= 0; i--) {\n      const oldLog = previousLogs[i];\n\n      // Ensure that updated blocks are fetched every time the log's block number\n      // changes.\n      if (oldLog.blockNumber !== blockHead.number) {\n        blockHead = await this.getBlockByNumber(fromHex(oldLog.blockNumber));\n      }\n\n      // Since logs are ordered in ascending order, the first log that matches\n      // the hash should be the largest logIndex.\n      if (oldLog.blockHash === blockHead.hash) {\n        return {\n          blockNumber: fromHex(oldLog.blockNumber),\n          logIndex: fromHex(oldLog.logIndex)\n        };\n      }\n    }\n    return {\n      blockNumber: Number.NEGATIVE_INFINITY,\n      logIndex: Number.NEGATIVE_INFINITY\n    };\n  }\n\n  /**\n   * Gets all `logs` events in the provided range. Note that the returned logs\n   * do not include removed logs.\n   *\n   * @private\n   */ private async getLogsInRange(\n    filter: LogsSubscriptionFilter,\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<LogsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const rangeFilter: GetLogsOptions = {\n      ...filter,\n      fromBlock: toHex(fromBlockInclusive),\n      toBlock: toHex(toBlockExclusive - 1)\n    };\n    return this.provider.send('eth_getLogs', [rangeFilter]);\n  }\n}\n\nfunction toNewHeadsEvent(head: BlockHead): NewHeadsEvent {\n  const result: NewHeadsEvent & Partial<BlockHead> = { ...head };\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\n\nexport function dedupeNewHeads(events: NewHeadsEvent[]): NewHeadsEvent[] {\n  return dedupe(events, event => event.hash);\n}\n\nexport function dedupeLogs(events: LogsEvent[]): LogsEvent[] {\n  return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\n}\n\nfunction dedupe<T>(items: T[], getKey: (item: T) => any): T[] {\n  const keysSeen: Set<any> = new Set();\n  const result: T[] = [];\n  items.forEach(item => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\n\nconst CANCELLED = new Error('Cancelled');\nexport function throwIfCancelled(isCancelled: () => boolean): void {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\n","import SturdyWebSocket from 'sturdy-websocket';\n\nimport { Listener } from '@ethersproject/abstract-provider';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport {\n  Networkish,\n  getNetwork as getNetworkFromEthers\n} from '@ethersproject/networks';\nimport { Network as NetworkFromEthers } from '@ethersproject/networks/lib/types';\nimport {\n  CommunityResourcable,\n  WebSocketProvider\n} from '@ethersproject/providers';\n\nimport {\n  EthersEvent,\n  getAlchemyEventTag,\n  isAlchemyEvent,\n  verifyAlchemyEventName\n} from '../internal/ethers-event';\nimport {\n  ALCHEMY_EVENT_TYPES,\n  ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE,\n  ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  SingleOrBatchResponse,\n  SubscriptionEvent,\n  WebSocketMessage\n} from '../internal/internal-types';\nimport {\n  BatchPart,\n  LogsEvent,\n  LogsSubscriptionFilter,\n  NewHeadsEvent,\n  WebsocketBackfiller,\n  dedupeLogs,\n  dedupeNewHeads,\n  throwIfCancelled\n} from '../internal/websocket-backfiller';\nimport { AlchemyEventType, AlchemySubscription } from '../types/types';\nimport {\n  CustomNetworks,\n  DEFAULT_ALCHEMY_API_KEY,\n  EthersNetwork,\n  noop\n} from '../util/const';\nimport { VERSION } from '../version';\nimport { AlchemyConfig } from './alchemy-config';\nimport { AlchemyProvider } from './alchemy-provider';\nimport { fromHex } from './util';\n\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\n\n/**\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\n *\n * Do not call this constructor directly. Instead, instantiate an instance of\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\n *\n * @public\n */\nexport class AlchemyWebSocketProvider\n  extends WebSocketProvider\n  implements CommunityResourcable\n{\n  _events: Array<EthersEvent> = [];\n  readonly apiKey: string;\n\n  // In the case of a WebSocket reconnection, all subscriptions are lost and we\n  // create new ones to replace them, but we want to create the illusion that\n  // the original subscriptions persist. Thus, maintain a mapping from the\n  // \"virtual\" subscription ids which are visible to the consumer to the\n  // \"physical\" subscription ids of the actual connections. This terminology is\n  // borrowed from virtual and physical memory, which has a similar mapping.\n  /** @internal */\n  private readonly virtualSubscriptionsById: Map<string, VirtualSubscription> =\n    new Map();\n  /** @internal */\n  private readonly virtualIdsByPhysicalId: Map<string, string> = new Map();\n  /** @internal */\n  private readonly backfiller: WebsocketBackfiller;\n  /** @internal */\n  private heartbeatIntervalId?: NodeJS.Timeout;\n  /** @internal */\n  private cancelBackfill: () => void;\n\n  /** @internal */\n  constructor(config: AlchemyConfig, wsConstructor?: any) {\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'wss'\n    );\n\n    const protocol = `alchemy-sdk-${VERSION}`;\n\n    // Use the provided config URL override if it exists, otherwise use the created one.\n    const ws = new SturdyWebSocket(config.url ?? connection.url, protocol, {\n      wsConstructor: wsConstructor ?? getWebsocketConstructor()\n    });\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(ws as any, ethersNetwork);\n    this.apiKey = apiKey;\n\n    // Start heartbeat and backfiller for the websocket connection.\n    this.backfiller = new WebsocketBackfiller(this);\n    this.addSocketListeners();\n    this.startHeartbeat();\n    this.cancelBackfill = noop;\n  }\n\n  /**\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\n   *\n   * This override allows the SDK to set the provider's network to values not\n   * yet supported by ethers.js.\n   *\n   * @internal\n   * @override\n   */\n  static getNetwork(network: Networkish): NetworkFromEthers {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetworkFromEthers(network);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based subscriptions.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  on(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, false);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based\n   * subscriptions. Adds a listener to the triggered for only the next\n   * {@link eventName} event, after which it will be removed.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  once(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, true);\n  }\n\n  /**\n   * Removes the provided {@link listener} for the {@link eventName} event. If no\n   * listener is provided, all listeners for the event will be removed.\n   *\n   * @param eventName Event to unlisten to.\n   * @param listener The listener function to remove.\n   * @override\n   * @public\n   */\n  off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (isAlchemyEvent(eventName)) {\n      return this._off(eventName, listener);\n    } else {\n      return super.off(eventName, listener);\n    }\n  }\n\n  /**\n   * Remove all listeners for the provided {@link eventName} event. If no event\n   * is provided, all events and their listeners are removed.\n   *\n   * @param eventName The event to remove all listeners for.\n   * @override\n   * @public\n   */\n  removeAllListeners(eventName?: AlchemyEventType): this {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._removeAllListeners(eventName);\n    } else {\n      return super.removeAllListeners(eventName);\n    }\n  }\n\n  /**\n   * Returns the number of listeners for the provided {@link eventName} event. If\n   * no event is provided, the total number of listeners for all events is returned.\n   *\n   * @param eventName The event to get the number of listeners for.\n   * @public\n   * @override\n   */\n  listenerCount(eventName?: AlchemyEventType): number {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listenerCount(eventName);\n    } else {\n      return super.listenerCount(eventName);\n    }\n  }\n\n  /**\n   * Returns an array of listeners for the provided {@link eventName} event. If\n   * no event is provided, all listeners will be included.\n   *\n   * @param eventName The event to get the listeners for.\n   * @public\n   * @override\n   */\n  listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listeners(eventName);\n    } else {\n      return super.listeners(eventName);\n    }\n  }\n\n  /**\n   * Overrides the method in `BaseProvider` in order to properly format the\n   * Alchemy subscription events.\n   *\n   * @internal\n   * @override\n   */\n  _addEventListener(\n    eventName: AlchemyEventType,\n    listener: Listener,\n    once: boolean\n  ): this {\n    if (isAlchemyEvent(eventName)) {\n      verifyAlchemyEventName(eventName);\n      const event = new EthersEvent(\n        getAlchemyEventTag(eventName),\n        listener,\n        once\n      );\n      this._events.push(event);\n      this._startEvent(event);\n      return this;\n    } else {\n      return super._addEventListener(eventName, listener, once);\n    }\n  }\n\n  /**\n   * Overrides the `_startEvent()` method in ethers.js's\n   * {@link WebSocketProvider} to include additional alchemy methods.\n   *\n   * @param event\n   * @override\n   * @internal\n   */\n  _startEvent(event: EthersEvent): void {\n    // Check if the event type is a custom Alchemy subscription.\n    const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\n    if (customLogicTypes.includes(event.type)) {\n      this.customStartEvent(event);\n    } else {\n      super._startEvent(event);\n    }\n  }\n\n  /**\n   * Overridden from ethers.js's {@link WebSocketProvider}\n   *\n   * Modified in order to add mappings for backfilling.\n   *\n   * @internal\n   * @override\n   */\n  async _subscribe(\n    tag: string,\n    param: Array<any>,\n    processFunc: (result: any) => void,\n    event?: EthersEvent\n  ): Promise<void> {\n    let subIdPromise = this._subIds[tag];\n\n    // BEGIN MODIFIED CODE\n    const startingBlockNumber = await this.getBlockNumber();\n    // END MODIFIED CODE\n\n    if (subIdPromise == null) {\n      subIdPromise = Promise.all(param).then(param => {\n        return this.send('eth_subscribe', param);\n      });\n      this._subIds[tag] = subIdPromise;\n    }\n    const subId = await subIdPromise;\n\n    // BEGIN MODIFIED CODE\n    const resolvedParams = await Promise.all(param);\n    this.virtualSubscriptionsById.set(subId, {\n      event: event!,\n      method: 'eth_subscribe',\n      params: resolvedParams,\n      startingBlockNumber,\n      virtualId: subId,\n      physicalId: subId,\n      sentEvents: [],\n      isBackfilling: false,\n      backfillBuffer: []\n    });\n    this.virtualIdsByPhysicalId.set(subId, subId);\n\n    // END MODIFIED CODE\n\n    this._subs[subId] = { tag, processFunc };\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @internal\n   * @override\n   */\n  emit(eventName: AlchemyEventType, ...args: Array<any>): boolean {\n    if (isAlchemyEvent(eventName)) {\n      let result = false;\n\n      const stopped: Array<EthersEvent> = [];\n\n      // This line is the only modified line from the original method.\n      const eventTag = getAlchemyEventTag(eventName);\n\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n\n        setTimeout(() => {\n          event.listener.apply(this, args);\n        }, 0);\n\n        result = true;\n\n        if (event.once) {\n          stopped.push(event);\n          return false;\n        }\n\n        return true;\n      });\n\n      stopped.forEach(event => {\n        this._stopEvent(event);\n      });\n\n      return result;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n\n  /** @internal */\n  async sendBatch(parts: BatchPart[]): Promise<any[]> {\n    let nextId = 0;\n    const payload: JsonRpcRequest[] = parts.map(({ method, params }) => {\n      return {\n        method,\n        params,\n        jsonrpc: '2.0',\n        id: `alchemy-sdk:${nextId++}`\n      };\n    });\n\n    return this.sendBatchConcurrently(payload);\n  }\n\n  /** @override */\n  destroy(): Promise<void> {\n    this.removeSocketListeners();\n    this.stopHeartbeatAndBackfill();\n    return super.destroy();\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\n   *\n   * This method is copied over directly in order to support Alchemy's\n   * subscription type by allowing the provider to properly stop Alchemy's\n   * subscription events.\n   *\n   * @internal\n   */\n  _stopEvent(event: EthersEvent): void {\n    let tag = event.tag;\n\n    // START MODIFIED CODE\n    if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\n      // There are remaining pending transaction listeners.\n      if (\n        this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length\n      ) {\n        return;\n      }\n      // END MODIFIED CODE\n    } else if (event.type === 'tx') {\n      // There are remaining transaction event listeners\n      if (this._events.filter(e => e.type === 'tx').length) {\n        return;\n      }\n      tag = 'tx';\n    } else if (this.listenerCount(event.event)) {\n      // There are remaining event listeners\n      return;\n    }\n\n    const subId = this._subIds[tag];\n    if (!subId) {\n      return;\n    }\n\n    delete this._subIds[tag];\n    void subId.then(subId => {\n      if (!this._subs[subId]) {\n        return;\n      }\n      delete this._subs[subId];\n      void this.send('eth_unsubscribe', [subId]);\n    });\n  }\n\n  /** @internal */\n  private addSocketListeners(): void {\n    this._websocket.addEventListener('message', this.handleMessage);\n    this._websocket.addEventListener('reopen', this.handleReopen);\n    this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /** @internal */\n  private removeSocketListeners(): void {\n    this._websocket.removeEventListener('message', this.handleMessage);\n    this._websocket.removeEventListener('reopen', this.handleReopen);\n    this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /**\n   * The underlying ethers {@link WebSocketProvider} already handles and emits\n   * messages. To allow backfilling, track all messages that are emitted.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleMessage = (event: MessageEvent): void => {\n    const message: WebSocketMessage = JSON.parse(event.data);\n    if (!isSubscriptionEvent(message)) {\n      return;\n    }\n    const physicalId = message.params.subscription;\n    const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n    if (!virtualId) {\n      return;\n    }\n    const subscription = this.virtualSubscriptionsById.get(virtualId)!;\n    if (subscription.method !== 'eth_subscribe') {\n      return;\n    }\n\n    switch (subscription.params[0]) {\n      case 'newHeads': {\n        const newHeadsSubscription = subscription as NewHeadsSubscription;\n        const newHeadsMessage = message as SubscriptionEvent<NewHeadsEvent>;\n        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n        const { result } = newHeadsMessage.params;\n        if (isBackfilling) {\n          addToNewHeadsEventsBuffer(backfillBuffer, result);\n        } else if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        } else {\n          // Ethers subscription mapping will emit the event, just store it.\n          this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        }\n        break;\n      }\n      case 'logs': {\n        const logsSubscription = subscription as LogsSubscription;\n        const logsMessage = message as SubscriptionEvent<LogsEvent>;\n        const { isBackfilling, backfillBuffer } = logsSubscription;\n        const { result } = logsMessage.params;\n        if (isBackfilling) {\n          addToLogsEventsBuffer(backfillBuffer, result);\n        } else if (virtualId !== physicalId) {\n          this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n        } else {\n          this.rememberEvent(virtualId, result, getLogsBlockNumber);\n        }\n        break;\n      }\n      default:\n        if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          const { result } = (message as SubscriptionEvent<unknown>).params;\n          this.emitEvent(virtualId, result);\n        }\n    }\n  };\n\n  /**\n   * When the websocket connection reopens:\n   *\n   * 1. Resubscribe to all existing subscriptions and start backfilling\n   * 2. Restart heart beat.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleReopen = () => {\n    this.virtualIdsByPhysicalId.clear();\n    const { cancel, isCancelled } = makeCancelToken();\n    this.cancelBackfill = cancel;\n    for (const subscription of this.virtualSubscriptionsById.values()) {\n      void (async () => {\n        try {\n          await this.resubscribeAndBackfill(isCancelled, subscription);\n        } catch (error) {\n          if (!isCancelled()) {\n            console.error(\n              `Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`,\n              error\n            );\n          }\n        }\n      })();\n    }\n    this.startHeartbeat();\n  };\n\n  /**\n   * Reopens the backfill based on\n   *\n   * @param isCancelled\n   * @param subscription\n   * @internal\n   */\n  private async resubscribeAndBackfill(\n    isCancelled: () => boolean,\n    subscription: VirtualSubscription\n  ): Promise<void> {\n    const {\n      virtualId,\n      method,\n      params,\n      sentEvents,\n      backfillBuffer,\n      startingBlockNumber\n    } = subscription;\n    subscription.isBackfilling = true;\n    backfillBuffer.length = 0;\n    try {\n      const physicalId = await this.send(method, params);\n      throwIfCancelled(isCancelled);\n      subscription.physicalId = physicalId;\n      this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n      switch (params[0]) {\n        case 'newHeads': {\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getNewHeadsBackfill(\n                  isCancelled,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\n          break;\n        }\n        case 'logs': {\n          const filter: LogsSubscriptionFilter = params[1] || {};\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getLogsBackfill(\n                  isCancelled,\n                  filter,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitLogsEvent(virtualId, event));\n          break;\n        }\n        default:\n          break;\n      }\n    } finally {\n      subscription.isBackfilling = false;\n      backfillBuffer.length = 0;\n    }\n  }\n\n  /**\n   * Cancels the heartbeat and any pending backfills being performed. This is\n   * called when the websocket connection goes down or is disconnected.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private stopHeartbeatAndBackfill = () => {\n    if (this.heartbeatIntervalId != null) {\n      clearInterval(this.heartbeatIntervalId);\n      this.heartbeatIntervalId = undefined;\n    }\n    this.cancelBackfill();\n  };\n\n  /** @internal */\n  private emitNewHeadsEvent(virtualId: string, result: NewHeadsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n\n  /** @internal */\n  private emitLogsEvent(virtualId: string, result: LogsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   *\n   * @internal\n   */\n  private emitAndRememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    this.rememberEvent(virtualId, result, getBlockNumber);\n    this.emitEvent(virtualId, result);\n  }\n\n  private emitEvent<T>(virtualId: string, result: T): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    this.emitGenericEvent(subscription, result);\n  }\n\n  /** @internal */\n  private rememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(\n      subscription.sentEvents,\n      { ...result },\n      getBlockNumber\n    );\n  }\n\n  /** @internal */\n  private emitGenericEvent(\n    subscription: VirtualSubscription,\n    result: any\n  ): void {\n    const emitFunction = this.emitProcessFn(subscription.event);\n    emitFunction(result);\n  }\n\n  /**\n   * Starts a heartbeat that pings the websocket server periodically to ensure\n   * that the connection stays open.\n   *\n   * @internal\n   */\n  private startHeartbeat(): void {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(async () => {\n      try {\n        await withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\n      } catch {\n        this._websocket.reconnect();\n      }\n    }, HEARTBEAT_INTERVAL);\n  }\n\n  /**\n   * This method sends the batch concurrently as individual requests rather than\n   * as a batch, which was the original implementation. The original batch logic\n   * is preserved in this implementation in order for faster porting.\n   *\n   * @param payload\n   * @internal\n   */\n  // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n  // TODO(errors): Use allSettled() once we have more error handling.\n  private async sendBatchConcurrently(\n    payload: JsonRpcRequest[]\n  ): Promise<unknown[]> {\n    return Promise.all(payload.map(req => this.send(req.method, req.params)));\n  }\n\n  /** @internal */\n  private customStartEvent(event: EthersEvent): void {\n    if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      const { fromAddress, toAddress, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          AlchemySubscription.PENDING_TRANSACTIONS,\n          { fromAddress, toAddress, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n      const { addresses, includeRemoved, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          AlchemySubscription.MINED_TRANSACTIONS,\n          { addresses, includeRemoved, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'block') {\n      void this._subscribe(\n        'block',\n        ['newHeads'],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'filter') {\n      void this._subscribe(\n        event.tag,\n        ['logs', this._getFilter(event.filter)],\n        this.emitProcessFn(event),\n        event\n      );\n    }\n  }\n\n  /** @internal */\n  private emitProcessFn(event: EthersEvent): (result: any) => void {\n    switch (event.type) {\n      case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\n        return result =>\n          this.emit(\n            {\n              method: AlchemySubscription.PENDING_TRANSACTIONS,\n              fromAddress: event.fromAddress,\n              toAddress: event.toAddress,\n              hashesOnly: event.hashesOnly\n            },\n            result\n          );\n      case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\n        return result =>\n          this.emit(\n            {\n              method: AlchemySubscription.MINED_TRANSACTIONS,\n              addresses: event.addresses,\n              includeRemoved: event.includeRemoved,\n              hashesOnly: event.hashesOnly\n            },\n            result\n          );\n      case 'block':\n        return result => {\n          const blockNumber = BigNumber.from(result.number).toNumber();\n          this._emitted.block = blockNumber;\n          this.emit('block', blockNumber);\n        };\n      case 'filter':\n        return result => {\n          if (result.removed == null) {\n            result.removed = false;\n          }\n          this.emit(event.filter, this.formatter.filterLog(result));\n        };\n      default:\n        throw new Error('Invalid event type to `emitProcessFn()`');\n    }\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.off()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (listener == null) {\n      return this.removeAllListeners(eventName);\n    }\n\n    const stopped: Array<EthersEvent> = [];\n\n    let found = false;\n    const eventTag = getAlchemyEventTag(eventName);\n    this._events = this._events.filter(event => {\n      if (event.tag !== eventTag || event.listener != listener) {\n        return true;\n      }\n      if (found) {\n        return true;\n      }\n      found = true;\n      stopped.push(event);\n      return false;\n    });\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _removeAllListeners(eventName: AlchemyEventType): this {\n    let stopped: Array<EthersEvent> = [];\n    if (eventName == null) {\n      stopped = this._events;\n\n      this._events = [];\n    } else {\n      const eventTag = getAlchemyEventTag(eventName);\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n        stopped.push(event);\n        return false;\n      });\n    }\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listenerCount(eventName?: AlchemyEventType): number {\n    if (!eventName) {\n      return this._events.length;\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events.filter(event => {\n      return event.tag === eventTag;\n    }).length;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName == null) {\n      return this._events.map(event => event.listener);\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events\n      .filter(event => event.tag === eventTag)\n      .map(event => event.listener);\n  }\n}\n\nfunction getWebsocketConstructor(): any {\n  return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\n}\n\nfunction isNodeEnvironment(): boolean {\n  return (\n    typeof process !== 'undefined' &&\n    process != null &&\n    process.versions != null &&\n    process.versions.node != null\n  );\n}\n\n/** @internal */\ninterface CancelToken {\n  cancel(): void;\n  isCancelled(): boolean;\n}\n\ninterface VirtualSubscription {\n  event: EthersEvent;\n  virtualId: string;\n  physicalId: string;\n  method: string;\n  params: any[];\n  isBackfilling: boolean;\n  startingBlockNumber: number;\n  sentEvents: any[];\n  backfillBuffer: any[];\n}\n\ninterface NewHeadsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['newHeads'];\n  isBackfilling: boolean;\n  sentEvents: NewHeadsEvent[];\n  backfillBuffer: NewHeadsEvent[];\n}\n\ninterface LogsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['logs', LogsSubscriptionFilter?];\n  isBackfilling: boolean;\n  sentEvents: LogsEvent[];\n  backfillBuffer: LogsEvent[];\n}\n\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken(): CancelToken {\n  let cancelled = false;\n  return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\n}\n\n// TODO(cleanup): replace with SDK's backoff implementation\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\n\nasync function withBackoffRetries<T>(\n  f: () => Promise<T>,\n  retryCount: number,\n  shouldRetry: (error: unknown) => boolean = () => true\n): Promise<T> {\n  let nextWaitTime = 0;\n  let i = 0;\n  while (true) {\n    try {\n      return await f();\n    } catch (error) {\n      i++;\n      if (i >= retryCount || !shouldRetry(error)) {\n        throw error;\n      }\n      await delay(nextWaitTime);\n      if (!shouldRetry(error)) {\n        throw error;\n      }\n      nextWaitTime =\n        nextWaitTime === 0\n          ? MIN_RETRY_DELAY\n          : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n    }\n  }\n}\n\nfunction delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), ms)\n    )\n  ]);\n}\n\nfunction getNewHeadsBlockNumber(event: NewHeadsEvent): number {\n  return fromHex(event.number);\n}\n\nfunction getLogsBlockNumber(event: LogsEvent): number {\n  return fromHex(event.blockNumber);\n}\n\nfunction isResponse(\n  message: WebSocketMessage\n): message is SingleOrBatchResponse {\n  return (\n    Array.isArray(message) ||\n    (message.jsonrpc === '2.0' && (message as JsonRpcResponse).id !== undefined)\n  );\n}\n\nfunction isSubscriptionEvent(\n  message: WebSocketMessage\n): message is SubscriptionEvent {\n  return !isResponse(message);\n}\n\nfunction addToNewHeadsEventsBuffer(\n  pastEvents: NewHeadsEvent[],\n  event: NewHeadsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\n\nfunction addToLogsEventsBuffer(\n  pastEvents: LogsEvent[],\n  event: LogsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n\n/**\n * Adds a new event to an array of events, evicting any events which are so old\n * that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer<T>(\n  pastEvents: T[],\n  event: T,\n  getBlockNumber: (event: T) => number\n): void {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(\n    e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT\n  );\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\n","export interface Options {\n    allClearResetTime?: number;\n    connectTimeout?: number;\n    debug?: boolean;\n    minReconnectDelay?: number;\n    maxReconnectDelay?: number;\n    maxReconnectAttempts?: number;\n    reconnectBackoffFactor?: number;\n    wsConstructor?: new (url: string, protocols?: string | string[]) => any;\n    shouldReconnect?(closeEvent: CloseEvent): boolean | Promise<boolean>;\n}\n\ninterface SturdyWebSocketEventMap extends WebSocketEventMap {\n    down: CloseEvent;\n    reopen: Event;\n}\n\ntype WebSocketListener<K extends keyof SturdyWebSocketEventMap> = (\n    this: WebSocket,\n    event: SturdyWebSocketEventMap[K],\n) => any;\n\ntype WebSocketListeners = {\n    [K in keyof SturdyWebSocketEventMap]?: Array<WebSocketListener<K>>;\n} & {\n    [key: string]: EventListenerOrEventListenerObject[];\n};\n\nconst SHOULD_RECONNECT_FALSE_MESSAGE =\n    \"Provided shouldReconnect() returned false. Closing permanently.\";\nconst SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE =\n    \"Provided shouldReconnect() resolved to false. Closing permanently.\";\n\nexport default class SturdyWebSocket implements WebSocket {\n    public static readonly DEFAULT_OPTIONS: Required<Options> = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: () => true,\n        wsConstructor: undefined!,\n    };\n\n    public static readonly CONNECTING = 0;\n    public static readonly OPEN = 1;\n    public static readonly CLOSING = 2;\n    public static readonly CLOSED = 3;\n\n    public onclose: ((event: CloseEvent) => void) | null = null;\n    public onerror: ((event: Event) => void) | null = null;\n    public onmessage: ((event: MessageEvent) => void) | null = null;\n    public onopen: ((event: Event) => void) | null = null;\n    public ondown: ((event: CloseEvent | undefined) => void) | null = null;\n    public onreopen: ((event: Event) => void) | null = null;\n    public readonly CONNECTING = SturdyWebSocket.CONNECTING;\n    public readonly OPEN = SturdyWebSocket.OPEN;\n    public readonly CLOSING = SturdyWebSocket.CLOSING;\n    public readonly CLOSED = SturdyWebSocket.CLOSED;\n\n    private readonly protocols?: string | string[];\n    private readonly options: Required<Options>;\n    private ws?: WebSocket;\n    private hasBeenOpened = false;\n    private isClosed = false;\n    private messageBuffer: any[] = [];\n    private nextRetryTime: number = 0;\n    private reconnectCount = 0;\n    private allClearTimeoutId?: any;\n    private connectTimeoutId?: any;\n    private binaryTypeInternal?: BinaryType;\n    private lastKnownExtensions = \"\";\n    private lastKnownProtocol = \"\";\n    private readonly listeners: WebSocketListeners = {};\n\n    constructor(url: string, options?: Options);\n    constructor(\n        url: string,\n        protocols: string | string[] | undefined,\n        options?: Options,\n    );\n    constructor(\n        public readonly url: string,\n        protocolsOrOptions?: string | string[] | Options,\n        options: Options = {},\n    ) {\n        if (\n            protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)\n        ) {\n            this.protocols = protocolsOrOptions;\n        } else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            } else {\n                throw new Error(\n                    \"WebSocket not present in global scope and no \" +\n                        \"wsConstructor option was provided.\",\n                );\n            }\n        }\n        this.openNewWebSocket();\n    }\n\n    public get binaryType(): BinaryType {\n        return this.binaryTypeInternal || \"blob\";\n    }\n\n    public set binaryType(binaryType: BinaryType) {\n        this.binaryTypeInternal = binaryType;\n        if (this.ws) {\n            this.ws.binaryType = binaryType;\n        }\n    }\n\n    public get bufferedAmount(): number {\n        let sum = this.ws ? this.ws.bufferedAmount : 0;\n        let hasUnknownAmount = false;\n        this.messageBuffer.forEach(data => {\n            const byteLength = getDataByteLength(data);\n            if (byteLength != null) {\n                sum += byteLength;\n            } else {\n                hasUnknownAmount = true;\n            }\n        });\n        if (hasUnknownAmount) {\n            this.debugLog(\n                \"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\",\n            );\n        }\n        return sum;\n    }\n\n    public get extensions(): string {\n        return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n    }\n\n    public get protocol(): string {\n        return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n    }\n\n    public get readyState(): number {\n        return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n    }\n\n    public close(code?: number, reason?: string): void {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    }\n\n    public send(data: any): void {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        } else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        } else {\n            this.messageBuffer.push(data);\n        }\n    }\n\n    public reconnect(): void {\n        if (this.isClosed) {\n            throw new Error(\n                \"Cannot call reconnect() on socket which is permanently closed.\",\n            );\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    }\n\n    public addEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    }\n\n    public dispatchEvent(event: Event): boolean {\n        return this.dispatchEventOfType(event.type, event);\n    }\n\n    public removeEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(\n                l => l !== listener,\n            );\n        }\n    }\n\n    private openNewWebSocket(): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { connectTimeout, wsConstructor } = this.options;\n        this.debugLog(`Opening new WebSocket to ${this.url}.`);\n        const ws: WebSocket = new wsConstructor(this.url, this.protocols);\n        ws.onclose = event => this.handleClose(event);\n        ws.onerror = event => this.handleError(event);\n        ws.onmessage = event => this.handleMessage(event);\n        ws.onopen = event => this.handleOpen(event);\n        this.connectTimeoutId = setTimeout(() => {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            this.clearConnectTimeout();\n            this.disposeSocket();\n            this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    }\n\n    private handleOpen(event: Event): void {\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        const { allClearResetTime } = this.options;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        } else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        } else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(message => this.send(message));\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(() => {\n            this.clearAllClearTimeout();\n            this.nextRetryTime = 0;\n            this.reconnectCount = 0;\n            const openTime = (allClearResetTime / 1000) | 0;\n            this.debugLog(\n                `WebSocket remained open for ${openTime} seconds. Resetting` +\n                    \" retry time and count.\",\n            );\n        }, allClearResetTime);\n    }\n\n    private handleMessage(event: MessageEvent): void {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    }\n\n    private handleClose(event: CloseEvent | undefined): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { maxReconnectAttempts, shouldReconnect } = this.options;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(\n                event,\n                this.getTooManyFailedReconnectsMessage(),\n            );\n            return;\n        }\n        const willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(\n                willReconnect,\n                event,\n                SHOULD_RECONNECT_FALSE_MESSAGE,\n            );\n        } else {\n            willReconnect.then(willReconnectResolved => {\n                if (this.isClosed) {\n                    return;\n                }\n                this.handleWillReconnect(\n                    willReconnectResolved,\n                    event,\n                    SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE,\n                );\n            });\n        }\n    }\n\n    private handleError(event: Event): void {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    }\n\n    private handleWillReconnect(\n        willReconnect: boolean,\n        event: CloseEvent | undefined,\n        denialReason: string,\n    ): void {\n        if (willReconnect) {\n            this.reestablishConnection();\n        } else {\n            this.stopReconnecting(event, denialReason);\n        }\n    }\n\n    private reestablishConnection(): void {\n        const {\n            minReconnectDelay,\n            maxReconnectDelay,\n            reconnectBackoffFactor,\n        } = this.options;\n        this.reconnectCount++;\n        const retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(\n            minReconnectDelay,\n            Math.min(\n                this.nextRetryTime * reconnectBackoffFactor,\n                maxReconnectDelay,\n            ),\n        );\n        setTimeout(() => this.openNewWebSocket(), retryTime);\n        const retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\n            `WebSocket was closed. Re-opening in ${retryTimeSeconds} seconds.`,\n        );\n    }\n\n    private stopReconnecting(\n        event: CloseEvent | undefined,\n        debugReason: string,\n    ): void {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    }\n\n    private shutdown(): void {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    }\n\n    private disposeSocket(closeCode?: number, reason?: string): void {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    }\n\n    private clearAllTimeouts(): void {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    }\n\n    private clearConnectTimeout(): void {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    }\n\n    private clearAllClearTimeout(): void {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    }\n\n    private dispatchEventOfType(type: string, event: any): boolean {\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(listener => this.callListener(listener, event));\n        }\n        return !event || !(event as Event).defaultPrevented;\n    }\n\n    private callListener(\n        listener: EventListenerOrEventListenerObject,\n        event: Event,\n    ): void {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        } else {\n            listener.handleEvent.call(this, event);\n        }\n    }\n\n    private debugLog(message: string): void {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    }\n\n    private getTooManyFailedReconnectsMessage(): string {\n        const { maxReconnectAttempts } = this.options;\n        return `Failed to reconnect after ${maxReconnectAttempts} ${pluralize(\n            \"attempt\",\n            maxReconnectAttempts,\n        )}. Closing permanently.`;\n    }\n}\n\nfunction applyDefaultOptions(options: Options): Required<Options> {\n    const result: any = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(key => {\n        const value = (options as any)[key];\n        result[key] =\n            value === undefined\n                ? (SturdyWebSocket.DEFAULT_OPTIONS as any)[key]\n                : value;\n    });\n    return result;\n}\n\nfunction getDataByteLength(data: any): number | undefined {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    } else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    } else if (data instanceof Blob) {\n        return data.size;\n    } else {\n        return undefined;\n    }\n}\n\nfunction pluralize(s: string, n: number): string {\n    return n === 1 ? s : `${s}s`;\n}\n\nfunction noop(): void {\n    // Nothing.\n}\n"],"names":["$ad2c604ba644dcfb$var$WebsocketBackfiller","constructor","provider","this","maxBackfillBlocks","getNewHeadsBackfill","isCancelled","previousHeads","fromBlockNumber","$ad2c604ba644dcfb$var$throwIfCancelled","toBlockNumber","getBlockNumber","length","getHeadEventsInRange","Math","max","lastSeenBlockNumber","$07xSV","f","number","minBlockNumber","reorgHeads","getReorgHeads","intermediateHeads","getLogsBackfill","filter","previousLogs","getLogsInRange","blockNumber","commonAncestor","getCommonAncestor","removedLogs","log","map","Object","assign","removed","fromBlockInclusive","Number","NEGATIVE_INFINITY","addedLogs","logIndex","setMaxBackfillBlock","newMax","blockNumberHex","send","toBlockExclusive","batchParts","i","push","method","params","t","sendBatch","$ad2c604ba644dcfb$var$toNewHeadsEvent","result","oldEvent","blockHead","getBlockByNumber","hash","reverse","oldLog","blockHash","rangeFilter","fromBlock","toBlock","head","totalDifficulty","transactions","uncles","$ad2c604ba644dcfb$var$dedupe","items","getKey","keysSeen","Set","forEach","item","key","has","add","$ad2c604ba644dcfb$var$CANCELLED","Error","$ad2c604ba644dcfb$var$RETAINED_EVENT_BLOCK_COUNT","$ad2c604ba644dcfb$export$f6c13301c7b76371","$i7Wzi","WebSocketProvider","config","wsConstructor","apiKey","$bq21X","AlchemyProvider","getApiKey","alchemyNetwork","getAlchemyNetwork","network","connection","getAlchemyConnectionInfo","protocol","V","super","$parcel$interopDefault","$5R2ui","_a","url","$ibaza","versions","node","parcelRequire","w3cwebsocket","WebSocket","E","_events","virtualSubscriptionsById","Map","virtualIdsByPhysicalId","handleMessage","event","message","JSON","parse","data","Array","isArray","jsonrpc","undefined","id","$ad2c604ba644dcfb$var$isResponse","$ad2c604ba644dcfb$var$isSubscriptionEvent","physicalId","subscription","virtualId","get","newHeadsSubscription","newHeadsMessage","isBackfilling","backfillBuffer","pastEvents","$ad2c604ba644dcfb$var$addToPastEventsBuffer","$ad2c604ba644dcfb$var$getNewHeadsBlockNumber","$ad2c604ba644dcfb$var$addToNewHeadsEventsBuffer","emitAndRememberEvent","rememberEvent","logsSubscription","logsMessage","$ad2c604ba644dcfb$var$getLogsBlockNumber","$ad2c604ba644dcfb$var$addToLogsEventsBuffer","emitEvent","handleReopen","clear","cancel","cancelled","$ad2c604ba644dcfb$var$makeCancelToken","cancelBackfill","values","_","resubscribeAndBackfill","error","console","startHeartbeat","stopHeartbeatAndBackfill","heartbeatIntervalId","clearInterval","backfiller","addSocketListeners","n","getNetwork","C","getNetworkFromEthers","on","eventName","listener","_addEventListener","once","off","_off","removeAllListeners","_removeAllListeners","listenerCount","_listenerCount","listeners","_listeners","v","c","e","_startEvent","A","includes","type","customStartEvent","_subscribe","tag","param","processFunc","subIdPromise","_subIds","startingBlockNumber","Promise","all","then","subId","resolvedParams","set","sentEvents","_subs","emit","args","stopped","eventTag","setTimeout","apply","_stopEvent","parts","nextId","payload","sendBatchConcurrently","destroy","removeSocketListeners","isCommunityResource","D","_websocket","addEventListener","removeEventListener","backfillEvents","$ad2c604ba644dcfb$var$withBackoffRetries","$ad2c604ba644dcfb$var$withTimeout","events","$ad2c604ba644dcfb$var$dedupeNewHeads","emitNewHeadsEvent","$ad2c604ba644dcfb$var$dedupeLogs","emitLogsEvent","emitGenericEvent","emitProcessFn","emitFunction","setInterval","reconnect","req","h","fromAddress","toAddress","hashesOnly","j","PENDING_TRANSACTIONS","k","addresses","includeRemoved","MINED_TRANSACTIONS","_getFilter","$3HDBd","BigNumber","from","toNumber","_emitted","block","formatter","filterLog","found","$ad2c604ba644dcfb$var$MIN_RETRY_DELAY","$ad2c604ba644dcfb$var$RETRY_BACKOFF_FACTOR","$ad2c604ba644dcfb$var$MAX_RETRY_DELAY","retryCount","shouldRetry","nextWaitTime","$ad2c604ba644dcfb$var$delay","min","ms","resolve","promise","race","reject","currentBlockNumber","firstGoodIndex","findIndex","splice","$4433d4fff50a186a$var$SturdyWebSocket","SturdyWebSocket","protocolsOrOptions","options","onclose","onerror","onmessage","onopen","ondown","onreopen","CONNECTING","OPEN","CLOSING","CLOSED","hasBeenOpened","isClosed","messageBuffer","nextRetryTime","reconnectCount","lastKnownExtensions","lastKnownProtocol","protocols","keys","DEFAULT_OPTIONS","value","$4433d4fff50a186a$var$applyDefaultOptions","openNewWebSocket","defineProperty","prototype","binaryTypeInternal","binaryType","ws","sum","bufferedAmount","hasUnknownAmount","byteLength","ArrayBuffer","Blob","size","$4433d4fff50a186a$var$getDataByteLength","debugLog","extensions","close","code","reason","disposeSocket","shutdown","readyState","handleClose","dispatchEvent","dispatchEventOfType","l","_this","connectTimeout","handleError","handleOpen","connectTimeoutId","clearConnectTimeout","allClearResetTime","allClearTimeoutId","clearAllClearTimeout","openTime","maxReconnectAttempts","shouldReconnect","stopReconnecting","getTooManyFailedReconnectsMessage","willReconnect","handleWillReconnect","willReconnectResolved","denialReason","reestablishConnection","minReconnectDelay","maxReconnectDelay","reconnectBackoffFactor","retryTime","retryTimeSeconds","debugReason","clearAllTimeouts","closeCode","$4433d4fff50a186a$var$noop","clearTimeout","slice","callListener","defaultPrevented","call","handleEvent","debug","s","POSITIVE_INFINITY","module","exports","default"],"version":3,"file":"alchemy-websocket-provider-a2f83072.2dbb5d02.js.map"}
{"mappings":"I,E,E,C,E,C,E,A,W,iB,E,Q,E,Q,S,C,C,C,E,O,c,C,E,O,C,2B,C,I,I,E,I,K,E,W,C,E,a,C,C,G,I,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,E,S,E,S,I,E,E,QEuEA;;;;;;;;CAQG,EACU,MAAA,EAGX,YAA6B,CAAkC,CAAA,CAAlC,IAAQ,CAAA,QAAA,CAAR,E,0C;AADrB,IAAiB,CAAA,iBAAA,CAbC,GAcyC,CAEnE;;;;;;;KAOG,EACG,oBACJ,CAA0B,CAC1B,CAA8B,CAC9B,CAAuB,CAAA,C,M,A,C,E,E,C,A,E,I,C,K,E,K,E,YAEvB,EAAiB,GACjB,IAAM,EAAgB,MAAM,IAAI,CAAC,cAAc,E,mE;A,uE;AAK/C,GAJA,EAAiB,GAIb,AAAyB,IAAzB,EAAc,MAAM,CACtB,OAAO,IAAI,CAAC,oBAAoB,CAC9B,KAAK,GAAG,CAAC,EAAiB,EAAgB,IAAI,CAAC,iBAAiB,EAAI,EACpE,EAAgB,E,0E;A,2E;A,a;AAOpB,IAAM,EAAsB,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAC1B,CAAa,CAAC,EAAc,MAAM,CAAG,EAAE,CAAC,MAAM,EAE1C,EAAiB,EAAgB,IAAI,CAAC,iBAAiB,CAAG,EAChE,GAAI,GAAuB,EACzB,OAAO,IAAI,CAAC,oBAAoB,CAAC,EAAgB,EAAgB,E,0E;A,+E;AAKnE,IAAM,EAA8B,MAAM,IAAI,CAAC,aAAa,CAC1D,EACA,GAEF,EAAiB,GACjB,IAAM,EAAqC,MAAM,IAAI,CAAC,oBAAoB,CACxE,EAAsB,EACtB,EAAgB,GAGlB,OADA,EAAiB,GACV,IAAI,KAAe,EAAkB,AAC7C,EAAA,CAED;;;;;;;KAOG,EACG,gBACJ,CAA0B,CAC1B,CAA8B,CAC9B,CAAyB,CACzB,CAAuB,CAAA,C,M,A,C,E,E,C,A,E,I,C,K,E,K,E,YAEvB,EAAiB,GACjB,IAAM,EAAgB,MAAM,IAAI,CAAC,cAAc,E,iE;A,yE;AAK/C,GAJA,EAAiB,GAIb,AAAwB,IAAxB,EAAa,MAAM,CACrB,OAAO,IAAI,CAAC,cAAc,CACxB,EACA,KAAK,GAAG,CAAC,EAAiB,EAAgB,IAAI,CAAC,iBAAiB,EAAI,EACpE,EAAgB,E,wE;A,wE;A,iB;AAOpB,IAAM,EAAsB,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAC1B,CAAY,CAAC,EAAa,MAAM,CAAG,EAAE,CAAC,WAAW,EAE7C,EAAiB,EAAgB,IAAI,CAAC,iBAAiB,CAAG,EAChE,GAAI,EAAsB,EACxB,OAAO,IAAI,CAAC,cAAc,CAAC,EAAQ,EAAgB,EAAgB,E,4E;A,qC;AAKrE,IAAM,EAAiB,MAAM,IAAI,CAAC,iBAAiB,CACjD,EACA,GAEF,EAAiB,E,0E;A,+C;AAIjB,IAAM,EAAc,EACjB,MAAM,CAAC,AAAA,GAAO,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAQ,EAAI,WAAW,EAAI,EAAe,WAAW,EACnE,GAAG,CAAC,AAAA,GAAO,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,EAAM,GAAG,CAAE,QAAS,CAAA,CAAI,IAIhC,EACJ,EAAe,WAAW,GAAK,OAAO,iBAAiB,CACnD,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAQ,CAAY,CAAC,EAAE,CAAC,WAAW,EACnC,EAAe,WAAW,CAC5B,EAAY,MAAM,IAAI,CAAC,cAAc,CACvC,EACA,EACA,EAAgB,GAYlB,O,8C;AARA,EAAY,EAAU,MAAM,CAC1B,AAAA,GACE,GACC,CAAA,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAQ,EAAI,WAAW,EAAI,EAAe,WAAW,EACpD,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAQ,EAAI,QAAQ,EAAI,EAAe,QAAA,AAAA,GAG7C,EAAiB,GACV,IAAI,KAAgB,EAAU,CACtC,EAAA,CAED;;;;KAIG,EACH,oBAAoB,CAAc,CAAA,CAChC,IAAI,CAAC,iBAAiB,CAAG,CAC1B,CAED;;;;KAIG,EACW,gBAAc,C,M,A,C,E,E,C,A,E,I,C,K,E,K,E,YAC1B,IAAM,EAAyB,MAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,mBACxD,MAAO,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAQ,EAChB,EAAA,CAED;;;;;;KAMG,EACW,qBACZ,CAA0B,CAC1B,CAAwB,CAAA,C,M,A,C,E,E,C,A,E,I,C,K,E,K,E,YAExB,GAAI,GAAsB,EACxB,MAAO,EAAE,CAEX,IAAM,EAA0B,EAAE,CAClC,IAAK,IAAI,EAAI,EAAoB,EAAI,EAAkB,IACrD,EAAW,IAAI,CAAC,CACd,OAAQ,uBACR,OAAQ,CAAC,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAM,GAAI,CAAA,EAAM,AAC1B,E,uB;AAIH,IAAM,EAAa,MAAM,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,GACjD,OAAO,EAAW,GAAG,CAAC,EACvB,EAAA,CAED;;;;KAIG,EACW,cACZ,CAA0B,CAC1B,CAA8B,CAAA,C,M,A,C,E,E,C,A,E,I,C,K,E,K,E,YAE9B,IAAM,EAA0B,EAAE,C,yE;A,mC;AAGlC,IAAK,IAAI,EAAI,EAAc,MAAM,CAAG,EAAG,GAAK,EAAG,IAAK,CAClD,IAAM,EAAW,CAAa,CAAC,EAAE,CAC3B,EAAY,MAAM,IAAI,CAAC,gBAAgB,CAAC,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAQ,EAAS,MAAM,E,6E;AAIrE,GAHA,EAAiB,GAGb,EAAS,IAAI,GAAK,EAAU,IAAI,CAClC,MAGF,EAAO,IAAI,CAAC,EAAgB,GAC7B,CACD,OAAO,EAAO,OAAO,EACtB,EAAA,CAED;;;;;KAKG,EACW,iBAAiB,CAAmB,CAAA,C,M,A,C,E,E,C,A,E,I,C,K,E,K,E,YAChD,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,uBAAwB,CAChD,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAM,GACN,CAAA,EACD,CACF,EAAA,CAED;;;;;;;;;KASG,EACW,kBACZ,CAA0B,CAC1B,CAAyB,CAAA,C,M,A,C,E,E,C,A,E,I,C,K,E,K,E,Y,yE;A,mC;AAIzB,IAAI,EAAY,MAAM,IAAI,CAAC,gBAAgB,CACzC,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAQ,CAAY,CAAC,EAAa,MAAM,CAAG,EAAE,CAAC,WAAW,GAE3D,EAAiB,GACjB,IAAK,IAAI,EAAI,EAAa,MAAM,CAAG,EAAG,GAAK,EAAG,IAAK,CACjD,IAAM,EAAS,CAAY,CAAC,EAAE,A,yE;A,2C;AAU9B,GANI,EAAO,WAAW,GAAK,EAAU,MAAM,EACzC,CAAA,EAAY,MAAM,IAAI,CAAC,gBAAgB,CAAC,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAQ,EAAO,WAAW,EADpE,EAMI,EAAO,SAAS,GAAK,EAAU,IAAI,CACrC,MAAO,CACL,YAAa,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAQ,EAAO,WAAW,EACvC,SAAU,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAQ,EAAO,QAAQ,CAClC,CAEJ,CACD,MAAO,CACL,YAAa,OAAO,iBAAiB,CACrC,SAAU,OAAO,iBAAiB,AACnC,CACF,EAAA,CAED;;;;;KAKG,EAAe,eAChB,CAA8B,CAC9B,CAA0B,CAC1B,CAAwB,CAAA,C,M,A,C,E,E,C,A,E,I,C,K,E,K,E,YAExB,GAAI,GAAsB,EACxB,MAAO,EAAE,CAEX,IAAM,EAAW,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,EACZ,GAAM,CACT,UAAW,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAM,GACjB,QAAS,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAM,EAAmB,EAAE,GAEtC,OAAO,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAe,CAAC,EAAY,CACvD,EAAA,CACF,CAED,SAAS,EAAgB,CAAe,EACtC,IAAM,EAAM,OAAA,MAAA,CAAA,CAAA,EAA4C,GAIxD,OAHA,OAAO,EAAO,eAAe,CAC7B,OAAO,EAAO,YAAY,CAC1B,OAAO,EAAO,MAAM,CACb,CACT,CAUA,SAAS,EAAU,CAAU,CAAE,CAAwB,EACrD,IAAM,EAAqB,IAAI,IACzB,EAAc,EAAE,CAQtB,OAPA,EAAM,OAAO,CAAC,AAAA,IACZ,IAAM,EAAM,EAAO,GACd,EAAS,GAAG,CAAC,KAChB,EAAS,GAAG,CAAC,GACb,EAAO,IAAI,CAAC,GAEhB,GACO,CACT,CAEA,IAAM,EAAY,AAAI,MAAM,aACtB,SAAU,EAAiB,CAA0B,EACzD,GAAI,IACF,MAAM,CAEV,CC5UA;;;;;;;CAOG,EACG,MAAO,UACH,EAAA,iBAAA,C,c,EAyBR,YAAY,CAAqB,CAAE,CAAmB,CAAA,K,C,sC;AAEpD,IAAM,EAAS,AAAA,CAAA,EAAA,EAAA,eAAA,AAAA,EAAgB,SAAS,CAAC,EAAO,MAAM,EAGhD,EAAiB,AAAA,CAAA,EAAA,EAAA,eAAA,AAAA,EAAgB,iBAAiB,CAAC,EAAO,OAAO,EACjE,EAAa,AAAA,CAAA,EAAA,EAAA,eAAA,AAAA,EAAgB,wBAAwB,CACzD,EACA,EACA,OAGI,EAAW,CAAe,YAAA,EAAA,EAAA,CAAA,CAAO,CAAE,CAGnC,EAAK,G,C,AAAI,G,AAAA,E,U,C,AAAA,E,O,CAAA,C,EAAgB,AAAU,OAAV,CAAA,EAAA,EAAO,GAAG,AAAH,GAAG,AAAA,KAAA,IAAA,EAAA,EAAI,EAAW,GAAG,CAAE,EAAU,CACrE,cAAe,MAAA,EAAA,EAg2BZ,AAKL,AAAmB,KAAA,IAAZ,GACP,AAAW,MAAX,GACA,AAAoB,MAApB,EAAQ,QAAQ,EAChB,AAAyB,MAAzB,EAAQ,QAAQ,CAAC,IAAI,CARM,AAAA,EAAA,SAAA,YAAA,CAAoC,SA/1B9D,GAKK,EAAgB,AAAA,EAAA,CAAA,AAAa,CAAC,EAAe,CACnD,KAAK,CAAC,EAAW,GA7CnB,IAAO,CAAA,OAAA,CAAuB,EAAE,C,6E;A,2E;A,wE;A,sE;A,6E;A,0E;A,c,EAUf,IAAA,CAAA,wBAAwB,CACvC,IAAI,I,c,EAEW,IAAA,CAAA,sBAAsB,CAAwB,IAAI,IAwYnE;;;;;;;;SAQG,EACK,IAAA,CAAA,aAAa,CAAG,AAAC,QA2lBzB,EA1lBE,IAAM,EAA4B,KAAK,KAAK,CAAC,EAAM,IAAI,EACvD,GAmlBA,MAAM,OAAO,CAMf,EAzlB2B,IAolBxB,AAAoB,QAApB,AAOgB,EAPR,OAAO,EAAe,AAAmC,KAAA,IAAnC,AAOd,EAP0C,EAAE,CAnlB3D,OAEF,IAAM,EAAa,EAAQ,MAAM,CAAC,YAAY,CACxC,EAAY,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,GAClD,GAAI,CAAC,EACH,OAEF,IAAM,EAAe,IAAI,CAAC,wBAAwB,CAAC,GAAG,CAAC,GACvD,GAAI,AAAwB,kBAAxB,EAAa,MAAM,CAIvB,OAAQ,EAAa,MAAM,CAAC,EAAE,EAC5B,IAAK,WAAY,CAGf,GAAM,CAAA,cAAE,CAAa,CAAA,eAAE,CAAc,CAAE,CAFV,EAGvB,CAAA,OAAE,CAAM,CAAE,CAAG,AAFK,EAEW,MAAM,CACrC,EA+kBV,EA9kBkC,EAAgB,EA8kBT,GA7kBxB,IAAe,E,4B;AAGxB,IAAI,CAAC,oBAAoB,CAAC,EAAW,EAAQ,GAG7C,IAAI,CAAC,aAAa,CAAC,EAAW,EAAQ,GAExC,KACD,CACD,IAAK,OAAQ,CAGX,GAAM,CAAA,cAAE,CAAa,CAAA,eAAE,CAAc,CAAE,CAFd,EAGnB,CAAA,OAAE,CAAM,CAAE,CAAG,AAFC,EAEW,MAAM,CACjC,EAqkBV,EApkB8B,EAAgB,EAokBL,GAnkBxB,IAAc,EACvB,IAAI,CAAC,oBAAoB,CAAC,EAAW,EAAQ,GAE7C,IAAI,CAAC,aAAa,CAAC,EAAW,EAAQ,GAExC,KACD,CACD,QACE,GAAI,IAAe,EAAW,C,oE;A,4B;AAG5B,GAAM,CAAA,OAAE,CAAM,CAAE,CAAI,EAAuC,MAAM,CACjE,IAAI,CAAC,SAAS,CAAC,EAAW,EAC3B,CACJ,CACH,EAEA;;;;;;;;;;SAUG,EACK,IAAY,CAAA,YAAA,CAAG,SAodnB,EAndF,IAAI,CAAC,sBAAsB,CAAC,KAAK,GACjC,GAAM,CAAA,OAAE,CAAM,CAAA,YAAE,CAAW,CAAE,EAkd3B,EAAY,CAAA,EACT,CAAE,OAAQ,IAAO,EAAY,CAAA,EAAO,YAAa,IAAM,CAAS,GAjdrE,IAAK,IAAM,KADX,IAAI,CAAC,cAAc,CAAG,EACK,IAAI,CAAC,wBAAwB,CAAC,MAAM,IAC5C,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAA,IAAA,CAAA,KAAA,EAAA,KAAA,EAAA,YACf,GAAI,CACF,MAAM,IAAI,CAAC,sBAAsB,CAAC,EAAa,EAChD,CAAC,MAAO,EAAO,CACT,KACH,QAAQ,KAAK,CACX,CAAA,yBAAA,EAA4B,EAAa,MAAM,CAAC,EAAE,CAAA,2CAAA,CAA6C,CAC/F,EAGL,CACF,GAEH,IAAI,CAAC,cAAc,EACrB,EA8EA;;;;;;;;SAQG,EACK,IAAwB,CAAA,wBAAA,CAAG,KACD,MAA5B,IAAI,CAAC,mBAAmB,GAC1B,cAAc,IAAI,CAAC,mBAAmB,EACtC,IAAI,CAAC,mBAAmB,CAAG,KAAA,GAE7B,IAAI,CAAC,cAAc,EACrB,EApiBE,IAAI,CAAC,MAAM,CAAG,E,+D;AAGd,IAAI,CAAC,UAAU,CAAG,IAAI,EAAoB,IAAI,EAC9C,IAAI,CAAC,kBAAkB,GACvB,IAAI,CAAC,cAAc,GACnB,IAAI,CAAC,cAAc,CAAG,EAAA,CAAA,AACvB,CAED;;;;;;;;KAQG,EACH,OAAO,WAAW,CAAmB,CAAA,OACnC,AAAI,AAAmB,UAAnB,OAAO,GAAwB,KAAW,EAAA,CAAA,CACrC,AAAA,EAAA,CAAA,AAAc,CAAC,EAAQ,CAIzBsW,AAAAA,CAAAA,EAAAA,EAAAA,UAAAA,AAAAA,EAAqB,EAC7B,CAED;;;;;;;KAOG,E,8D;AAEH,GAAG,CAA2B,CAAE,CAAkB,CAAA,CAChD,OAAO,IAAI,CAAC,iBAAiB,CAAC,EAAW,EAAU,CAAA,EACpD,CAED;;;;;;;;;KASG,E,8D;AAEH,KAAK,CAA2B,CAAE,CAAkB,CAAA,CAClD,OAAO,IAAI,CAAC,iBAAiB,CAAC,EAAW,EAAU,CAAA,EACpD,CAED;;;;;;;;KAQG,EACH,IAAI,CAA2B,CAAE,CAAmB,CAAA,OAClD,AAAI,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAe,GACV,IAAI,CAAC,IAAI,CAAC,EAAW,GAErB,KAAK,CAAC,IAAI,EAAW,EAE/B,CAED;;;;;;;KAOG,EACH,mBAAmB,CAA4B,CAAA,QAC7C,AAAI,AAAc,KAAA,IAAd,GAA2B,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAe,GACrC,IAAI,CAAC,mBAAmB,CAAC,GAEzB,KAAK,CAAC,mBAAmB,EAEnC,CAED;;;;;;;KAOG,EACH,cAAc,CAA4B,CAAA,QACxC,AAAI,AAAc,KAAA,IAAd,GAA2B,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAe,GACrC,IAAI,CAAC,cAAc,CAAC,GAEpB,KAAK,CAAC,cAAc,EAE9B,CAED;;;;;;;KAOG,EACH,UAAU,CAA4B,CAAA,QACpC,AAAI,AAAc,KAAA,IAAd,GAA2B,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAe,GACrC,IAAI,CAAC,UAAU,CAAC,GAEhB,KAAK,CAAC,UAAU,EAE1B,CAED;;;;;;KAMG,EACH,kBACE,CAA2B,CAC3B,CAAkB,CAClB,CAAa,CAAA,CAEb,IAAI,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAe,GAWjB,OAAO,KAAK,CAAC,kBAAkB,EAAW,EAAU,EAXvB,EAC7B,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAuB,GACvB,IAAM,EAAQ,IAAI,EAAA,CAAA,CAChB,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAmB,GACnB,EACA,GAIF,OAFA,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAClB,IAAI,CAAC,WAAW,CAAC,GACV,IAAI,AACZ,CAGF,CAED;;;;;;;KAOG,EACH,YAAY,CAAkB,CAAA,C,4D;AAE5B,IAAM,EAAmB,IAAI,EAAA,CAAA,CAAqB,QAAS,SAAS,CAChE,EAAiB,QAAQ,CAAC,EAAM,IAAI,EACtC,IAAI,CAAC,gBAAgB,CAAC,GAEtB,KAAK,CAAC,YAAY,EAErB,CAED;;;;;;;KAOG,EACG,WACJ,CAAW,CACX,CAAiB,CACjB,CAAkC,CAClC,CAAmB,CAAA,C,M,A,C,E,E,C,A,E,I,C,K,E,K,E,YAEnB,IAAI,EAAe,IAAI,CAAC,OAAO,CAAC,EAAI,CAG9B,EAAsB,MAAM,IAAI,CAAC,cAAc,EAGjC,OAAhB,IACF,EAAe,QAAQ,GAAG,CAAC,GAAO,IAAI,CAAC,AAAA,GAC9B,IAAI,CAAC,IAAI,CAAC,gBAAiB,IAEpC,IAAI,CAAC,OAAO,CAAC,EAAI,CAAG,GAEtB,IAAM,EAAQ,MAAM,EAGd,EAAiB,MAAM,QAAQ,GAAG,CAAC,GACzC,IAAI,CAAC,wBAAwB,CAAC,GAAG,CAAC,EAAO,CACvC,MAAO,EACP,OAAQ,gBACR,OAAQ,EACR,oBAAA,EACA,UAAW,EACX,WAAY,EACZ,WAAY,EAAE,CACd,cAAe,CAAA,EACf,eAAgB,EAAE,AACnB,GACD,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,EAAO,G,oB;AAIvC,IAAI,CAAC,KAAK,CAAC,EAAM,CAAG,CAAE,IAAA,EAAK,YAAA,CAAW,CACvC,EAAA,CAED;;;;;;;;;;;;KAYG,EACH,KAAK,CAA2B,CAAE,GAAG,CAAgB,CAAA,CACnD,IAAI,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAe,GAiCjB,OAAO,KAAK,CAAC,KAAK,KAAc,EAjCH,EAC7B,IAAI,EAAS,CAAA,EAEP,EAA8B,EAAE,CAGhC,EAAW,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAmB,GAyBpC,OAvBA,IAAI,CAAC,OAAO,CAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,AAAA,GACjC,AAAI,EAAM,GAAG,GAAK,IAIlB,WAAW,KACT,EAAM,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAE,EAC5B,EAAE,GAEH,EAAS,CAAA,GAEL,EAAM,IAAI,GACZ,EAAQ,IAAI,CAAC,GACN,CAAA,KAMX,EAAQ,OAAO,CAAC,AAAA,IACd,IAAI,CAAC,UAAU,CAAC,EAClB,GAEO,CACR,CAGF,C,c,EAGK,UAAU,CAAkB,CAAA,C,M,A,C,E,E,C,A,E,I,C,K,E,K,E,YAChC,IAAI,EAAS,EACP,EAA4B,EAAM,GAAG,CAAC,CAAC,CAAA,OAAE,CAAM,CAAA,OAAE,CAAM,CAAE,GACtD,CAAA,CACL,OAAA,EACA,OAAA,EACA,QAAS,MACT,GAAI,CAAA,YAAA,EAAe,IAAU,CAAA,AAC9B,CAAA,GAGH,OAAO,IAAI,CAAC,qBAAqB,CAAC,EACnC,EAAA,C,c,EAGD,SAAO,CAGL,OAFA,IAAI,CAAC,qBAAqB,GAC1B,IAAI,CAAC,wBAAwB,GACtB,KAAK,CAAC,SACd,CAED;;;;;KAKG,EACH,qBAAmB,CACjB,OAAO,IAAI,CAAC,MAAM,GAAK,EAAA,CAAA,AACxB,CAED;;;;;;;;;;KAUG,EACH,WAAW,CAAkB,CAAA,CAC3B,IAAI,EAAM,EAAM,GAAG,A,uB;AAGnB,GAAI,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAoB,QAAQ,CAAC,EAAM,IAAI,E,qD;AAEzC,CAAA,GACE,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,AAAA,GAAK,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAoB,QAAQ,CAAC,EAAE,IAAI,GAAG,MAAM,CAErE,MAHF,MAMK,GAAI,AAAe,OAAf,EAAM,IAAI,CAAW,C,kD;AAE9B,GAAI,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,AAAA,GAAK,AAAW,OAAX,EAAE,IAAI,EAAW,MAAM,CAClD,OAEF,EAAM,IACP,MAAM,GAAI,IAAI,CAAC,aAAa,CAAC,EAAM,KAAK,EAEvC,OAGF,IAAM,EAAQ,IAAI,CAAC,OAAO,CAAC,EAAI,CAC1B,IAIL,OAAO,IAAI,CAAC,OAAO,CAAC,EAAI,CACnB,EAAM,IAAI,CAAC,AAAA,IACT,IAAI,CAAC,KAAK,CAAC,EAAM,GAGtB,OAAO,IAAI,CAAC,KAAK,CAAC,EAAM,CACnB,IAAI,CAAC,IAAI,CAAC,kBAAmB,CAAC,EAAM,EAC3C,GACD,C,c,EAGO,oBAAkB,CACxB,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC,UAAW,IAAI,CAAC,aAAa,EAC9D,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC,SAAU,IAAI,CAAC,YAAY,EAC5D,IAAI,CAAC,UAAU,CAAC,gBAAgB,CAAC,OAAQ,IAAI,CAAC,wBAAwB,CACvE,C,c,EAGO,uBAAqB,CAC3B,IAAI,CAAC,UAAU,CAAC,mBAAmB,CAAC,UAAW,IAAI,CAAC,aAAa,EACjE,IAAI,CAAC,UAAU,CAAC,mBAAmB,CAAC,SAAU,IAAI,CAAC,YAAY,EAC/D,IAAI,CAAC,UAAU,CAAC,mBAAmB,CAAC,OAAQ,IAAI,CAAC,wBAAwB,CAC1E,CAoGD;;;;;;KAMG,EACW,uBACZ,CAA0B,CAC1B,CAAiC,CAAA,C,M,A,C,E,E,C,A,E,I,C,K,E,K,E,YAEjC,GAAM,CAAA,UACJ,CAAS,CAAA,OACT,CAAM,CAAA,OACN,CAAM,CAAA,WACN,CAAU,CAAA,eACV,CAAc,CAAA,oBACd,CAAmB,CACpB,CAAG,CACJ,CAAA,EAAa,aAAa,CAAG,CAAA,EAC7B,EAAe,MAAM,CAAG,EACxB,GAAI,KDtOuB,EAIJ,ECmOrB,IAAM,EAAa,MAAM,IAAI,CAAC,IAAI,CAAC,EAAQ,GAI3C,OAHA,EAAiB,GACjB,EAAa,UAAU,CAAG,EAC1B,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,EAAY,GACpC,CAAM,CAAC,EAAE,EACf,IAAK,WAAY,CACf,IAAM,EAAiB,MAAM,EAC3B,IACE,EACE,IAAI,CAAC,UAAU,CAAC,mBAAmB,CACjC,EACA,EACA,GAnjBO,KACA,EAujBb,IAAM,CAAC,KAET,EAAiB,GACjB,IAAM,GD3Pe,EC2PS,IAAI,KAAmB,EAAe,CD1PrE,EAAO,EAAQ,AAAA,GAAS,EAAM,IAAI,GC2PjC,EAAO,OAAO,CAAC,AAAA,GAAS,IAAI,CAAC,iBAAiB,CAAC,EAAW,IAC1D,KACD,CACD,IAAK,OAAQ,CACX,IAAM,EAAiC,CAAM,CAAC,EAAE,EAAI,CAAA,EAC9C,EAAiB,MAAM,EAC3B,IACE,EACE,IAAI,CAAC,UAAU,CAAC,eAAe,CAC7B,EACA,EACA,EACA,GAxkBO,KACA,EA4kBb,IAAM,CAAC,KAET,EAAiB,GACjB,IAAM,GD5QW,EC4QS,IAAI,KAAmB,EAAe,CD3QjE,EAAO,EAAQ,AAAA,GAAS,CAAA,EAAG,EAAM,SAAS,CAAI,CAAA,EAAA,EAAM,QAAQ,CAAA,CAAE,GC4Q7D,EAAO,OAAO,CAAC,AAAA,GAAS,IAAI,CAAC,aAAa,CAAC,EAAW,GAEvD,CAGF,CACF,QAAS,CACR,EAAa,aAAa,CAAG,CAAA,EAC7B,EAAe,MAAM,CAAG,CACzB,CACF,EAAA,C,c,EAoBO,kBAAkB,CAAiB,CAAE,CAAqB,CAAA,CAChE,IAAI,CAAC,oBAAoB,CAAC,EAAW,EAAQ,EAC9C,C,c,EAGO,cAAc,CAAiB,CAAE,CAAiB,CAAA,CACxD,IAAI,CAAC,oBAAoB,CAAC,EAAW,EAAQ,EAC9C,CAED;;;;;;KAMG,EACK,qBACN,CAAiB,CACjB,CAAS,CACT,CAAqC,CAAA,CAErC,IAAI,CAAC,aAAa,CAAC,EAAW,EAAQ,GACtC,IAAI,CAAC,SAAS,CAAC,EAAW,EAC3B,CAEO,UAAa,CAAiB,CAAE,CAAS,CAAA,CAC/C,IAAM,EAAe,IAAI,CAAC,wBAAwB,CAAC,GAAG,CAAC,GAClD,GAGL,IAAI,CAAC,gBAAgB,CAAC,EAAc,EACrC,C,c,EAGO,cACN,CAAiB,CACjB,CAAS,CACT,CAAqC,CAAA,CAErC,IAAM,EAAe,IAAI,CAAC,wBAAwB,CAAC,GAAG,CAAC,GAClD,G,uE;A,uE;A,Q;AAML,EACE,EAAa,UAAU,CAAA,OAAA,MAAA,CAAA,CAAA,EAClB,GACL,EAEH,C,c,EAGO,iBACN,CAAiC,CACjC,CAAW,CAAA,CAEX,IAAM,EAAe,IAAI,CAAC,aAAa,CAAC,EAAa,KAAK,EAC1D,EAAa,EACd,CAED;;;;;KAKG,EACK,gBAAc,CACY,MAA5B,IAAI,CAAC,mBAAmB,EAG5B,CAAA,IAAI,CAAC,mBAAmB,CAAG,YAAY,IAAW,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAA,IAAA,CAAA,KAAA,EAAA,KAAA,EAAA,YAChD,GAAI,CACF,MAAM,EAAY,IAAI,CAAC,IAAI,CAAC,eA1rBR,IA2rBrB,CAAC,MAAM,EAAA,CACN,IAAI,CAAC,UAAU,CAAC,SAAS,EAC1B,CACH,GA/rBuB,IA+rBvB,CACD,CAED;;;;;;;KAOG,E,8D;A,mE;AAGW,sBACZ,CAAyB,CAAA,C,M,A,C,E,E,C,A,E,I,C,K,E,K,E,YAEzB,OAAO,QAAQ,GAAG,CAAC,EAAQ,GAAG,CAAC,AAAA,GAAO,IAAI,CAAC,IAAI,CAAC,EAAI,MAAM,CAAE,EAAI,MAAM,GACvE,EAAA,C,c,EAGO,iBAAiB,CAAkB,CAAA,CACzC,GAAI,EAAM,IAAI,GAAK,EAAA,CAAA,CAAyC,CAC1D,GAAM,CAAA,YAAE,CAAW,CAAA,UAAE,CAAS,CAAA,WAAE,CAAU,CAAE,CAAG,EAC1C,IAAI,CAAC,UAAU,CAClB,EAAM,GAAG,CACT,CACE,AAAA,EAAA,CAAA,CAAoB,oBAAoB,CACxC,CAAE,YAAA,EAAa,UAAA,EAAW,WAAA,CAAU,EACrC,CACD,IAAI,CAAC,aAAa,CAAC,GACnB,EAEH,MAAM,GAAI,EAAM,IAAI,GAAK,EAAA,CAAA,CAAuC,CAC/D,GAAM,CAAA,UAAE,CAAS,CAAA,eAAE,CAAc,CAAA,WAAE,CAAU,CAAE,CAAG,EAC7C,IAAI,CAAC,UAAU,CAClB,EAAM,GAAG,CACT,CACE,AAAA,EAAA,CAAA,CAAoB,kBAAkB,CACtC,CAAE,UAAA,EAAW,eAAA,EAAgB,WAAA,CAAU,EACxC,CACD,IAAI,CAAC,aAAa,CAAC,GACnB,EAEH,KAAU,AAAe,UAAf,EAAM,IAAI,CACd,IAAI,CAAC,UAAU,CAClB,QACA,CAAC,WAAW,CACZ,IAAI,CAAC,aAAa,CAAC,GACnB,GAEsB,WAAf,EAAM,IAAI,EACd,IAAI,CAAC,UAAU,CAClB,EAAM,GAAG,CACT,CAAC,OAAQ,IAAI,CAAC,UAAU,CAAC,EAAM,MAAM,EAAE,CACvC,IAAI,CAAC,aAAa,CAAC,GACnB,EAGL,C,c,EAGO,cAAc,CAAkB,CAAA,CACtC,OAAQ,EAAM,IAAI,EAChB,KAAK,EAAL,CAAA,CACE,OAAO,AAAA,GACL,IAAI,CAAC,IAAI,CACP,CACE,OAAQ,AAAA,EAAA,CAAA,CAAoB,oBAAoB,CAChD,YAAa,EAAM,WAAW,CAC9B,UAAW,EAAM,SAAS,CAC1B,WAAY,EAAM,UAAU,AAC7B,EACD,EAEN,MAAK,EAAL,CAAA,CACE,OAAO,AAAA,GACL,IAAI,CAAC,IAAI,CACP,CACE,OAAQ,AAAA,EAAA,CAAA,CAAoB,kBAAkB,CAC9C,UAAW,EAAM,SAAS,CAC1B,eAAgB,EAAM,cAAc,CACpC,WAAY,EAAM,UAAU,AAC7B,EACD,EAEN,KAAK,QACH,OAAO,AAAA,IACL,IAAM,EAAc,AAAA,CAAA,EAAA,EAAA,SAAA,AAAA,EAAU,IAAI,CAAC,EAAO,MAAM,EAAE,QAAQ,EAC1D,CAAA,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAG,EACtB,IAAI,CAAC,IAAI,CAAC,QAAS,EACrB,CACF,KAAK,SACH,OAAO,AAAA,IACiB,MAAlB,EAAO,OAAO,EAChB,CAAA,EAAO,OAAO,CAAG,CAAA,CADnB,EAGA,IAAI,CAAC,IAAI,CAAC,EAAM,MAAM,CAAE,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,GACnD,CACF,SACE,MAAM,AAAI,MAAM,0CACnB,CACF,CAED;;;;;;;;;;;KAWG,EACK,KAAK,CAA2B,CAAE,CAAmB,CAAA,CAC3D,GAAI,AAAY,MAAZ,EACF,OAAO,IAAI,CAAC,kBAAkB,CAAC,GAGjC,IAAM,EAA8B,EAAE,CAElC,EAAQ,CAAA,EACN,EAAW,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAmB,GAiBpC,OAhBA,IAAI,CAAC,OAAO,CAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,AAAA,GACjC,AAAI,EAAM,GAAG,GAAK,GAAY,EAAM,QAAQ,EAAI,KAG5C,IAGJ,EAAQ,CAAA,EACR,EAAQ,IAAI,CAAC,GACN,CAAA,IAGT,EAAQ,OAAO,CAAC,AAAA,IACd,IAAI,CAAC,UAAU,CAAC,EAClB,GAEO,IAAI,AACZ,CAED;;;;;;;;;;;KAWG,EACK,oBAAoB,CAA2B,CAAA,CACrD,IAAI,EAA8B,EAAE,CACpC,GAAI,AAAa,MAAb,EACF,EAAU,IAAI,CAAC,OAAO,CAEtB,IAAI,CAAC,OAAO,CAAG,EAAE,KACZ,CACL,IAAM,EAAW,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAmB,EACpC,CAAA,IAAI,CAAC,OAAO,CAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,AAAA,GACjC,AAAI,EAAM,GAAG,GAAK,IAGlB,EAAQ,IAAI,CAAC,GACN,CAAA,GAEV,CAMD,OAJA,EAAQ,OAAO,CAAC,AAAA,IACd,IAAI,CAAC,UAAU,CAAC,EAClB,GAEO,IAAI,AACZ,CAED;;;;;;;;;;;KAWG,EACK,eAAe,CAA4B,CAAA,CACjD,GAAI,CAAC,EACH,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAG5B,IAAM,EAAW,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAmB,GACpC,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,AAAA,GAClB,EAAM,GAAG,GAAK,GACpB,MAAM,AACV,CAED;;;;;;;;;;;KAWG,EACK,WAAW,CAA4B,CAAA,CAC7C,GAAI,AAAa,MAAb,EACF,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,AAAA,GAAS,EAAM,QAAQ,EAGjD,IAAM,EAAW,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAmB,GACpC,OAAO,IAAI,CAAC,OAAO,CAChB,MAAM,CAAC,AAAA,GAAS,EAAM,GAAG,GAAK,GAC9B,GAAG,CAAC,AAAA,GAAS,EAAM,QAAQ,CAC/B,CACF,CA4DD,SAAe,EACb,CAAmB,CACnB,CAAkB,CAClB,EAA2C,IAAM,CAAA,CAAI,E,M,A,C,E,E,C,A,E,I,C,K,E,K,E,YAErD,IAAI,EAAe,EACf,EAAI,EACR,OACE,GAAI,CACF,OAAO,MAAM,GACd,CAAC,MAAO,EAAO,CAEd,KAAI,GAAK,GAAc,CAAC,EAAY,KAGpC,MAAM,AAYZ,SAAe,CAAU,EACvB,OAAO,IAAI,QAAQ,AAAA,GAAW,WAAW,EAAS,GACpD,EAdkB,GACR,CAAC,EAAY,IAHf,MAAM,EAMR,EACE,AAAiB,IAAjB,EAxBgB,IA0BZ,KAAK,GAAG,CAxBI,IAwBc,AAzBT,EAyBgC,EACxD,CAEJ,EAAA,CAMD,SAAS,EAAe,CAAmB,CAAE,CAAU,EACrD,OAAO,QAAQ,IAAI,CAAC,CAClB,EACA,IAAI,QAAW,CAAC,EAAG,IACjB,WAAW,IAAM,EAAO,AAAI,MAAM,YAAa,IAElD,CACH,CAEA,SAAS,EAAuB,CAAoB,EAClD,MAAO,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAQ,EAAM,MAAM,CAC7B,CAEA,SAAS,EAAmB,CAAgB,EAC1C,MAAO,AAAA,CAAA,EAAA,EAAA,CAAA,AAAA,EAAQ,EAAM,WAAW,CAClC,CA+BA;;;CAGG,EACH,SAAS,EACP,CAAe,CACf,CAAQ,CACR,CAAoC,EAEpC,IAAM,EAAqB,EAAe,GAGpC,EAAiB,EAAW,SAAS,CACzC,AAAA,GAAK,EAAe,GAAK,EAviCM,GAyiC7B,AAAmB,CAAA,KAAnB,EACF,EAAW,MAAM,CAAG,EAEpB,EAAW,MAAM,CAAC,EAAG,GAEvB,EAAW,IAAI,CAAC,EAClB,C,G,E,Q,S,C,C,C,E,O,c,C,E,O,C,a,C,M,C,C,GEhlCA,IAAA,EAAA,WAAA,EAAA,WAkDI,SAAA,EACoB,CAAW,CAC3B,CAAgD,CAChD,CAAqB,MA2YA,EACnB,EAhYF,GAZA,KAAA,IAAA,GAAA,CAAA,EAAA,CAAA,CAAA,EAFgB,IAAA,CAAA,GAAG,CAAH,EAjCb,IAAA,CAAA,OAAO,CAAyC,KAChD,IAAA,CAAA,OAAO,CAAoC,KAC3C,IAAA,CAAA,SAAS,CAA2C,KACpD,IAAA,CAAA,MAAM,CAAoC,KAC1C,IAAA,CAAA,MAAM,CAAqD,KAC3D,IAAA,CAAA,QAAQ,CAAoC,KACnC,IAAA,CAAA,UAAU,CAAG,EAAgB,UAAU,CACvC,IAAA,CAAA,IAAI,CAAG,EAAgB,IAAI,CAC3B,IAAA,CAAA,OAAO,CAAG,EAAgB,OAAO,CACjC,IAAA,CAAA,MAAM,CAAG,EAAgB,MAAM,CAKvC,IAAA,CAAA,aAAa,CAAG,CAAA,EAChB,IAAA,CAAA,QAAQ,CAAG,CAAA,EACX,IAAA,CAAA,aAAa,CAAU,EAAE,CACzB,IAAA,CAAA,aAAa,CAAW,EACxB,IAAA,CAAA,cAAc,CAAG,EAIjB,IAAA,CAAA,mBAAmB,CAAG,GACtB,IAAA,CAAA,iBAAiB,CAAG,GACX,IAAA,CAAA,SAAS,CAAuB,CAAA,EAczC,AAAsB,MAAtB,GACA,AAA8B,UAA9B,OAAO,GACP,MAAM,OAAO,CAAC,GAEd,IAAI,CAAC,SAAS,CAAG,EAEjB,EAAU,EAEd,IAAI,CAAC,OAAO,EAgYS,EAhYc,EAiYjC,EAAc,CAAA,EACpB,OAAO,IAAI,CAAC,EAAgB,eAAe,EAAE,OAAO,CAAC,SAAA,CAAG,EACpD,IAAM,EAAS,CAAe,CAAC,EAAI,AACnC,CAAA,CAAM,CAAC,EAAI,CACP,AAAU,KAAA,IAAV,EACO,EAAgB,eAAuB,CAAC,EAAI,CAC7C,CACd,GACO,GAxYC,CAAC,IAAI,CAAC,OAAO,CAAC,aAAa,EAC3B,GAAI,AAAqB,aAArB,OAAO,UACP,IAAI,CAAC,OAAO,CAAC,aAAa,CAAG,eAE7B,MAAM,AAAI,MACN,mFAKZ,IAAI,CAAC,gBAAgB,EACzB,CAkXJ,OAhXI,OAAA,cAAA,CAAW,EAAA,SAAA,CAAA,aAAX,CAAA,IAAA,WACI,OAAO,IAAI,CAAC,kBAAkB,EAAI,MACtC,EAEA,IAAA,SAAsB,CAAsB,EACxC,IAAI,CAAC,kBAAkB,CAAG,EACtB,IAAI,CAAC,EAAE,EACP,CAAA,IAAI,CAAC,EAAE,CAAC,UAAU,CAAG,CADzB,CAGJ,E,W,C,E,a,C,CAPC,GASD,OAAA,cAAA,CAAW,EAAA,SAAA,CAAA,iBAAX,CAAA,IAAA,WACI,IAAI,EAAM,IAAI,CAAC,EAAE,CAAG,IAAI,CAAC,EAAE,CAAC,cAAc,CAAG,EACzC,EAAmB,CAAA,EAevB,OAdA,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,SAAA,CAAI,EAC3B,IAAM,EAgXd,AAAI,AAAgB,UAAhB,OAhXyC,EAkXlC,EAAI,AAlX8B,EAkXzB,MAAM,CACf,AAnXkC,aAmXlB,YAChB,AApXkC,EAoX7B,UAAU,CACf,AArXkC,aAqXlB,KAChB,AAtXkC,EAsX7B,IAAI,CAEhB,KAAA,CAvXQ,AAAc,OAAd,EACA,GAAO,EAEP,EAAmB,CAAA,CAE3B,GACI,GACA,IAAI,CAAC,QAAQ,CACT,yGAID,CACX,E,W,C,E,a,C,CAAC,GAED,OAAA,cAAA,CAAW,EAAA,SAAA,CAAA,aAAX,CAAA,IAAA,WACI,OAAO,IAAI,CAAC,EAAE,CAAG,IAAI,CAAC,EAAE,CAAC,UAAU,CAAG,IAAI,CAAC,mBAAmB,AAClE,E,W,C,E,a,C,CAAC,GAED,OAAA,cAAA,CAAW,EAAA,SAAA,CAAA,WAAX,CAAA,IAAA,WACI,OAAO,IAAI,CAAC,EAAE,CAAG,IAAI,CAAC,EAAE,CAAC,QAAQ,CAAG,IAAI,CAAC,iBAAiB,AAC9D,E,W,C,E,a,C,CAAC,GAED,OAAA,cAAA,CAAW,EAAA,SAAA,CAAA,aAAX,CAAA,IAAA,WACI,OAAO,IAAI,CAAC,QAAQ,CAAG,EAAgB,MAAM,CAAG,EAAgB,IAAI,AACxE,E,W,C,E,a,C,CAAC,GAEM,EAAA,SAAA,CAAA,KAAK,CAAZ,SAAa,CAAa,CAAE,CAAe,EACvC,IAAI,CAAC,aAAa,CAAC,EAAM,GACzB,IAAI,CAAC,QAAQ,GACb,IAAI,CAAC,QAAQ,CAAC,0CAClB,EAEO,EAAA,SAAA,CAAA,IAAI,CAAX,SAAY,CAAS,EACjB,GAAI,IAAI,CAAC,QAAQ,CACb,MAAM,AAAI,MAAM,mDACT,CAAA,IAAI,CAAC,EAAE,EAAI,IAAI,CAAC,EAAE,CAAC,UAAU,GAAK,IAAI,CAAC,IAAI,CAClD,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,GAEb,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,EAEhC,EAEO,EAAA,SAAA,CAAA,SAAS,CAAhB,WACI,GAAI,IAAI,CAAC,QAAQ,CACb,MAAM,AAAI,MACN,kEAGR,IAAI,CAAC,aAAa,CAAC,IAAM,+BACzB,IAAI,CAAC,WAAW,CAAC,KAAA,EACrB,EAUO,EAAA,SAAA,CAAA,gBAAgB,CAAvB,SACI,CAAY,CACZ,CAA4C,EAEvC,IAAI,CAAC,SAAS,CAAC,EAAK,EACrB,CAAA,IAAI,CAAC,SAAS,CAAC,EAAK,CAAG,EAAE,AAAF,EAE3B,IAAI,CAAC,SAAS,CAAC,EAAK,CAAC,IAAI,CAAC,EAC9B,EAEO,EAAA,SAAA,CAAA,aAAa,CAApB,SAAqB,CAAY,EAC7B,OAAO,IAAI,CAAC,mBAAmB,CAAC,EAAM,IAAI,CAAE,EAChD,EAUO,EAAA,SAAA,CAAA,mBAAmB,CAA1B,SACI,CAAY,CACZ,CAA4C,EAExC,IAAI,CAAC,SAAS,CAAC,EAAK,EACpB,CAAA,IAAI,CAAC,SAAS,CAAC,EAAK,CAAG,IAAI,CAAC,SAAS,CAAC,EAAK,CAAC,MAAM,CAC9C,SAAA,CAAC,EAAI,OAAA,IAAM,CAAN,EAAA,CAGjB,EAEQ,EAAA,SAAA,CAAA,gBAAgB,CAAxB,WAAA,IAAA,EAAA,IAAA,CACI,IAAI,IAAI,CAAC,QAAQ,EAGX,IAAA,EAAA,IAAA,CAAA,OAAgD,CAA9C,EAAA,EAAA,cAAc,CAAE,EAAA,EAAA,aAA8B,CACtD,IAAI,CAAC,QAAQ,CAAC,4BAA4B,IAAI,CAAC,GAAG,CAAA,KAClD,IAAM,EAAgB,IAAI,EAAc,IAAI,CAAC,GAAG,CAAE,IAAI,CAAC,SAAS,CAChE,CAAA,EAAG,OAAO,CAAG,SAAA,CAAK,EAAI,OAAA,EAAK,WAAW,CAAC,EAAjB,EACtB,EAAG,OAAO,CAAG,SAAA,CAAK,EAAI,OAAA,EAAK,WAAW,CAAC,EAAjB,EACtB,EAAG,SAAS,CAAG,SAAA,CAAK,EAAI,OAAA,EAAK,aAAa,CAAC,EAAnB,EACxB,EAAG,MAAM,CAAG,SAAA,CAAK,EAAI,OAAA,EAAK,UAAU,CAAC,EAAhB,EACrB,IAAI,CAAC,gBAAgB,CAAG,WAAW,WAC/B,6DAA6D;AAC7D,+BAA+B;AAC/B,EAAK,mBAAmB,GACxB,EAAK,aAAa,GAClB,EAAK,WAAW,CAAC,KAAA,EACrB,EAAG,GACH,IAAI,CAAC,EAAE,CAAG,EACd,EAEQ,EAAA,SAAA,CAAA,UAAU,CAAlB,SAAmB,CAAY,EAA/B,IAAA,EAAA,IAAA,CACI,GAAI,AAAC,IAAI,CAAC,EAAE,GAAI,IAAI,CAAC,QAAQ,EAGrB,IAAA,EAAA,IAAA,CAAA,OAAA,CAAA,iBAAiB,CACzB,IAAI,CAAC,QAAQ,CAAC,qBACV,AAA2B,MAA3B,IAAI,CAAC,kBAAkB,CACvB,IAAI,CAAC,EAAE,CAAC,UAAU,CAAG,IAAI,CAAC,kBAAkB,CAE5C,IAAI,CAAC,kBAAkB,CAAG,IAAI,CAAC,EAAE,CAAC,UAAU,CAEhD,IAAI,CAAC,mBAAmB,GACpB,IAAI,CAAC,aAAa,CAClB,IAAI,CAAC,mBAAmB,CAAC,SAAU,IAEnC,IAAI,CAAC,mBAAmB,CAAC,OAAQ,GACjC,IAAI,CAAC,aAAa,CAAG,CAAA,GAEzB,IAAI,CAAC,aAAa,CAAC,OAAO,CAAC,SAAA,CAAO,EAAI,OAAA,EAAK,IAAI,CAAC,EAAV,GACtC,IAAI,CAAC,aAAa,CAAG,EAAE,CACvB,IAAI,CAAC,iBAAiB,CAAG,WAAW,WAChC,EAAK,oBAAoB,GACzB,EAAK,aAAa,CAAG,EACrB,EAAK,cAAc,CAAG,EAEtB,EAAK,QAAQ,CACT,+BAFc,CAAA,EAAoB,IAAQ,CAAA,EAE1C,4CAGR,EAAG,GACP,EAEQ,EAAA,SAAA,CAAA,aAAa,CAArB,SAAsB,CAAmB,EACjC,IAAI,CAAC,QAAQ,EAGjB,IAAI,CAAC,mBAAmB,CAAC,UAAW,EACxC,EAEQ,EAAA,SAAA,CAAA,WAAW,CAAnB,SAAoB,CAA6B,EAAjD,IAAA,EAAA,IAAA,CACI,IAAI,IAAI,CAAC,QAAQ,EAGX,IAAA,EAAA,IAAA,CAAA,OAAwD,CAAtD,EAAA,EAAA,oBAAoB,CAAE,EAAA,EAAA,eAAgC,CAS9D,GARA,IAAI,CAAC,mBAAmB,GACxB,IAAI,CAAC,oBAAoB,GACrB,IAAI,CAAC,EAAE,GACP,IAAI,CAAC,mBAAmB,CAAG,IAAI,CAAC,EAAE,CAAC,UAAU,CAC7C,IAAI,CAAC,iBAAiB,CAAG,IAAI,CAAC,EAAE,CAAC,QAAQ,CACzC,IAAI,CAAC,aAAa,IAEtB,IAAI,CAAC,mBAAmB,CAAC,OAAQ,GAC7B,IAAI,CAAC,cAAc,EAAI,EAAsB,CAC7C,IAAI,CAAC,gBAAgB,CACjB,EACA,IAAI,CAAC,iCAAiC,IAE1C,MACH,CACD,IAAM,EAAgB,CAAC,GAAS,EAAgB,EAC5C,AAAyB,CAAA,WAAzB,OAAO,EACP,IAAI,CAAC,mBAAmB,CACpB,EACA,EApRZ,mEAwRQ,EAAc,IAAI,CAAC,SAAA,CAAqB,EAChC,EAAK,QAAQ,EAGjB,EAAK,mBAAmB,CACpB,EACA,EA5RhB,qEA+RQ,GAER,EAEQ,EAAA,SAAA,CAAA,WAAW,CAAnB,SAAoB,CAAY,EAC5B,IAAI,CAAC,mBAAmB,CAAC,QAAS,GAClC,IAAI,CAAC,QAAQ,CAAC,kCAClB,EAEQ,EAAA,SAAA,CAAA,mBAAmB,CAA3B,SACI,CAAsB,CACtB,CAA6B,CAC7B,CAAoB,EAEhB,EACA,IAAI,CAAC,qBAAqB,GAE1B,IAAI,CAAC,gBAAgB,CAAC,EAAO,EAErC,EAEQ,EAAA,SAAA,CAAA,qBAAqB,CAA7B,WAAA,IAAA,EAAA,IAAA,CACU,EAAA,IAAA,CAAA,OAIU,CAHZ,EAAA,EAAA,iBAAiB,CACjB,EAAA,EAAA,iBAAiB,CACjB,EAAA,EAAA,sBACY,AAChB,CAAA,IAAI,CAAC,cAAc,GACnB,IAAM,EAAY,IAAI,CAAC,aAAa,AACpC,CAAA,IAAI,CAAC,aAAa,CAAG,KAAK,GAAG,CACzB,EACA,KAAK,GAAG,CACJ,IAAI,CAAC,aAAa,CAAG,EACrB,IAGR,WAAW,WAAM,OAAA,EAAK,gBAAgB,EAArB,EAAyB,GAE1C,IAAI,CAAC,QAAQ,CACT,uCAFsB,CAAA,EAAY,IAAQ,CAAA,EAEa,YAE/D,EAEQ,EAAA,SAAA,CAAA,gBAAgB,CAAxB,SACI,CAA6B,CAC7B,CAAmB,EAEnB,IAAI,CAAC,QAAQ,CAAC,GACd,IAAI,CAAC,QAAQ,GACT,GACA,IAAI,CAAC,mBAAmB,CAAC,QAAS,EAE1C,EAEQ,EAAA,SAAA,CAAA,QAAQ,CAAhB,WACI,IAAI,CAAC,QAAQ,CAAG,CAAA,EAChB,IAAI,CAAC,gBAAgB,GACrB,IAAI,CAAC,aAAa,CAAG,EAAE,CACvB,IAAI,CAAC,aAAa,EACtB,EAEQ,EAAA,SAAA,CAAA,aAAa,CAArB,SAAsB,CAAkB,CAAE,CAAe,EAChD,IAAI,CAAC,EAAE,GAGZ,2DAA2D;AAC3D,wEAAwE;AACxE,oBAAoB;AACpB,IAAI,CAAC,EAAE,CAAC,OAAO,CAAG,EAClB,IAAI,CAAC,EAAE,CAAC,OAAO,CAAG,EAClB,IAAI,CAAC,EAAE,CAAC,SAAS,CAAG,EACpB,IAAI,CAAC,EAAE,CAAC,MAAM,CAAG,EACjB,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,EAAW,GACzB,IAAI,CAAC,EAAE,CAAG,KAAA,EACd,EAEQ,EAAA,SAAA,CAAA,gBAAgB,CAAxB,WACI,IAAI,CAAC,mBAAmB,GACxB,IAAI,CAAC,oBAAoB,EAC7B,EAEQ,EAAA,SAAA,CAAA,mBAAmB,CAA3B,WACiC,MAAzB,IAAI,CAAC,gBAAgB,GACrB,aAAa,IAAI,CAAC,gBAAgB,EAClC,IAAI,CAAC,gBAAgB,CAAG,KAAA,EAEhC,EAEQ,EAAA,SAAA,CAAA,oBAAoB,CAA5B,WACkC,MAA1B,IAAI,CAAC,iBAAiB,GACtB,aAAa,IAAI,CAAC,iBAAiB,EACnC,IAAI,CAAC,iBAAiB,CAAG,KAAA,EAEjC,EAEQ,EAAA,SAAA,CAAA,mBAAmB,CAA3B,SAA4B,CAAY,CAAE,CAAU,EAApD,IAAA,EAAA,IAAA,CACI,OAAQ,GACJ,IAAK,QACG,IAAI,CAAC,OAAO,EACZ,IAAI,CAAC,OAAO,CAAC,GAEjB,KACJ,KAAK,QACG,IAAI,CAAC,OAAO,EACZ,IAAI,CAAC,OAAO,CAAC,GAEjB,KACJ,KAAK,UACG,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,SAAS,CAAC,GAEnB,KACJ,KAAK,OACG,IAAI,CAAC,MAAM,EACX,IAAI,CAAC,MAAM,CAAC,GAEhB,KACJ,KAAK,OACG,IAAI,CAAC,MAAM,EACX,IAAI,CAAC,MAAM,CAAC,GAEhB,KACJ,KAAK,SACG,IAAI,CAAC,QAAQ,EACb,IAAI,CAAC,QAAQ,CAAC,EAGzB,CAMD,OALI,KAAQ,IAAI,CAAC,SAAS,EACtB,IAAI,CAAC,SAAS,CAAC,EAAK,CACf,KAAK,GACL,OAAO,CAAC,SAAA,CAAQ,EAAI,OAAA,EAAK,YAAY,CAAC,EAAU,EAA5B,GAEtB,CAAC,GAAS,CAAE,EAAgB,gBAAgB,AACvD,EAEQ,EAAA,SAAA,CAAA,YAAY,CAApB,SACI,CAA4C,CAC5C,CAAY,EAER,AAAoB,YAApB,OAAO,EACP,EAAS,IAAI,CAAC,IAAI,CAAE,GAEpB,EAAS,WAAW,CAAC,IAAI,CAAC,IAAI,CAAE,EAExC,EAEQ,EAAA,SAAA,CAAA,QAAQ,CAAhB,SAAiB,CAAe,EACxB,IAAI,CAAC,OAAO,CAAC,KAAK,EAElB,QAAQ,GAAG,CAAC,EAEpB,EAEQ,EAAA,SAAA,CAAA,iCAAiC,CAAzC,WACY,IAiCG,EAjCH,EAAA,IAAA,CAAA,OAAA,CAAA,oBAAoB,CAC5B,MAAO,6BAA6B,EAAoB,KAgC7C,EA/BP,UAgCD,AAAM,IA/BL,EA+BS,EAAO,EAAC,KA9BpB,wBACL,EA5buB,EAAA,eAAe,CAAsB,CACxD,kBAAmB,IACnB,eAAgB,IAChB,MAAO,CAAA,EACP,kBAAmB,IACnB,kBAAmB,IACnB,qBAAsB,OAAO,iBAAiB,CAC9C,uBAAwB,IACxB,gBAAiB,WAAM,MAAA,CAAA,CAAA,EACvB,cAAe,KAAA,CAClB,EAEsB,EAAA,UAAU,CAAG,EACb,EAAA,IAAI,CAAG,EACP,EAAA,OAAO,CAAG,EACV,EAAA,MAAM,CAAG,EA8apC,CAAC,IA+BD,SAAS,IACL,WAAW;AACf,CA/dqB,EAAA,OAAA,CAAA,OAAA,CAAA,C,E,0F","sources":["<anon>","node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-a2f83072.js","node_modules/alchemy-sdk/src/internal/websocket-backfiller.ts","node_modules/alchemy-sdk/src/api/alchemy-websocket-provider.ts","node_modules/sturdy-websocket/dist/index.js","node_modules/sturdy-websocket/src/index.ts"],"sourcesContent":["(() => {\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    var parcelRequire = $parcel$global[\"parcelRequire94c2\"];\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"eRNs9\", function(module, exports) {\n\n$parcel$export(module.exports, \"AlchemyWebSocketProvider\", () => $ad2c604ba644dcfb$export$f6c13301c7b76371);\n\nvar $07xSV = parcelRequire(\"07xSV\");\n\nvar $5R2ui = parcelRequire(\"5R2ui\");\n\nvar $3HDBd = parcelRequire(\"3HDBd\");\n\nvar $kYIxw = parcelRequire(\"kYIxw\");\n\nvar $i7Wzi = parcelRequire(\"i7Wzi\");\n\nvar $bq21X = parcelRequire(\"bq21X\");\n\nparcelRequire(\"kyCZa\");\n\n\n\n\n\nvar $ibaza = parcelRequire(\"ibaza\");\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */ const $ad2c604ba644dcfb$var$MAX_BACKFILL_BLOCKS = 120;\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */ class $ad2c604ba644dcfb$var$WebsocketBackfiller {\n    constructor(provider){\n        this.provider = provider;\n        // TODO: Use HTTP provider to do backfill.\n        this.maxBackfillBlocks = $ad2c604ba644dcfb$var$MAX_BACKFILL_BLOCKS;\n    }\n    /**\r\n     * Runs backfill for `newHeads` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param previousHeads Previous head requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     * @returns A list of `newHeads` events that were sent since the last backfill.\r\n     */ getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\n        return (0, $07xSV._)(this, void 0, void 0, function*() {\n            $ad2c604ba644dcfb$var$throwIfCancelled(isCancelled);\n            const toBlockNumber = yield this.getBlockNumber();\n            $ad2c604ba644dcfb$var$throwIfCancelled(isCancelled);\n            // If there are no previous heads to fetch, return new heads since\n            // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n            if (previousHeads.length === 0) return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\n            // If the last emitted event is too far back in the past, there's no need\n            // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n            // new heads.\n            const lastSeenBlockNumber = (0, $07xSV.f)(previousHeads[previousHeads.length - 1].number);\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n            if (lastSeenBlockNumber <= minBlockNumber) return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n            // To capture all `newHeads` events, return all head events from the last\n            // seen block number to current + any of the previous heads that were re-orged.\n            const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);\n            $ad2c604ba644dcfb$var$throwIfCancelled(isCancelled);\n            const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\n            $ad2c604ba644dcfb$var$throwIfCancelled(isCancelled);\n            return [\n                ...reorgHeads,\n                ...intermediateHeads\n            ];\n        });\n    }\n    /**\r\n     * Runs backfill for `logs` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param filter The filter object that accompanies a logs subscription.\r\n     * @param previousLogs Previous log requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     */ getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\n        return (0, $07xSV._)(this, void 0, void 0, function*() {\n            $ad2c604ba644dcfb$var$throwIfCancelled(isCancelled);\n            const toBlockNumber = yield this.getBlockNumber();\n            $ad2c604ba644dcfb$var$throwIfCancelled(isCancelled);\n            // If there are no previous logs to fetch, return new logs since\n            // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n            if (previousLogs.length === 0) return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\n            // If the last emitted log is too far back in the past, there's no need\n            // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n            // worth of logs.\n            const lastSeenBlockNumber = (0, $07xSV.f)(previousLogs[previousLogs.length - 1].blockNumber);\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n            if (lastSeenBlockNumber < minBlockNumber) return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n            // Return all log events that have happened along with log events that have\n            // been removed due to a chain reorg.\n            const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);\n            $ad2c604ba644dcfb$var$throwIfCancelled(isCancelled);\n            // All previous logs with a block number greater than the common ancestor\n            // were part of a re-org, so mark them as such.\n            const removedLogs = previousLogs.filter((log)=>(0, $07xSV.f)(log.blockNumber) > commonAncestor.blockNumber).map((log)=>Object.assign(Object.assign({}, log), {\n                    removed: true\n                }));\n            // If no common ancestor was found, start backfill from the oldest log's\n            // block number.\n            const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY ? (0, $07xSV.f)(previousLogs[0].blockNumber) : commonAncestor.blockNumber;\n            let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\n            // De-dupe any logs that were already emitted.\n            addedLogs = addedLogs.filter((log)=>log && ((0, $07xSV.f)(log.blockNumber) > commonAncestor.blockNumber || (0, $07xSV.f)(log.logIndex) > commonAncestor.logIndex));\n            $ad2c604ba644dcfb$var$throwIfCancelled(isCancelled);\n            return [\n                ...removedLogs,\n                ...addedLogs\n            ];\n        });\n    }\n    /**\r\n     * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */ setMaxBackfillBlock(newMax) {\n        this.maxBackfillBlocks = newMax;\n    }\n    /**\r\n     * Gets the current block number as a number.\r\n     *\r\n     * @private\r\n     */ getBlockNumber() {\n        return (0, $07xSV._)(this, void 0, void 0, function*() {\n            const blockNumberHex = yield this.provider.send(\"eth_blockNumber\");\n            return (0, $07xSV.f)(blockNumberHex);\n        });\n    }\n    /**\r\n     * Gets all `newHead` events in the provided range. Note that the returned\r\n     * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n     * that were part of a re-org.\r\n     *\r\n     * @private\r\n     */ getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\n        return (0, $07xSV._)(this, void 0, void 0, function*() {\n            if (fromBlockInclusive >= toBlockExclusive) return [];\n            const batchParts = [];\n            for(let i = fromBlockInclusive; i < toBlockExclusive; i++)batchParts.push({\n                method: \"eth_getBlockByNumber\",\n                params: [\n                    (0, $07xSV.t)(i),\n                    false\n                ]\n            });\n            // TODO: handle errors\n            const blockHeads = yield this.provider.sendBatch(batchParts);\n            return blockHeads.map($ad2c604ba644dcfb$var$toNewHeadsEvent);\n        });\n    }\n    /**\r\n     * Returns all heads that were part of a reorg event.\r\n     *\r\n     * @private\r\n     */ getReorgHeads(isCancelled, previousHeads) {\n        return (0, $07xSV._)(this, void 0, void 0, function*() {\n            const result = [];\n            // Iterate from the most recent head backwards in order to find the first\n            // block that was part of a re-org.\n            for(let i = previousHeads.length - 1; i >= 0; i--){\n                const oldEvent = previousHeads[i];\n                const blockHead = yield this.getBlockByNumber((0, $07xSV.f)(oldEvent.number));\n                $ad2c604ba644dcfb$var$throwIfCancelled(isCancelled);\n                // If the hashes match, then current head in the iteration was not re-orged.\n                if (oldEvent.hash === blockHead.hash) break;\n                result.push($ad2c604ba644dcfb$var$toNewHeadsEvent(blockHead));\n            }\n            return result.reverse();\n        });\n    }\n    /**\r\n     * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n     * block information for the provided block number.\r\n     *\r\n     * @private\r\n     */ getBlockByNumber(blockNumber) {\n        return (0, $07xSV._)(this, void 0, void 0, function*() {\n            return this.provider.send(\"eth_getBlockByNumber\", [\n                (0, $07xSV.t)(blockNumber),\n                false\n            ]);\n        });\n    }\n    /**\r\n     * Given a list of previous log events, finds the common block number from the\r\n     * logs that matches the block head.\r\n     *\r\n     * This can be used to identify which logs are part of a re-org.\r\n     *\r\n     * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n     *\r\n     * @private\r\n     */ getCommonAncestor(isCancelled, previousLogs) {\n        return (0, $07xSV._)(this, void 0, void 0, function*() {\n            // Iterate from the most recent head backwards in order to find the first\n            // block that was part of a re-org.\n            let blockHead = yield this.getBlockByNumber((0, $07xSV.f)(previousLogs[previousLogs.length - 1].blockNumber));\n            $ad2c604ba644dcfb$var$throwIfCancelled(isCancelled);\n            for(let i = previousLogs.length - 1; i >= 0; i--){\n                const oldLog = previousLogs[i];\n                // Ensure that updated blocks are fetched every time the log's block number\n                // changes.\n                if (oldLog.blockNumber !== blockHead.number) blockHead = yield this.getBlockByNumber((0, $07xSV.f)(oldLog.blockNumber));\n                // Since logs are ordered in ascending order, the first log that matches\n                // the hash should be the largest logIndex.\n                if (oldLog.blockHash === blockHead.hash) return {\n                    blockNumber: (0, $07xSV.f)(oldLog.blockNumber),\n                    logIndex: (0, $07xSV.f)(oldLog.logIndex)\n                };\n            }\n            return {\n                blockNumber: Number.NEGATIVE_INFINITY,\n                logIndex: Number.NEGATIVE_INFINITY\n            };\n        });\n    }\n    /**\r\n     * Gets all `logs` events in the provided range. Note that the returned logs\r\n     * do not include removed logs.\r\n     *\r\n     * @private\r\n     */ getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\n        return (0, $07xSV._)(this, void 0, void 0, function*() {\n            if (fromBlockInclusive >= toBlockExclusive) return [];\n            const rangeFilter = Object.assign(Object.assign({}, filter), {\n                fromBlock: (0, $07xSV.t)(fromBlockInclusive),\n                toBlock: (0, $07xSV.t)(toBlockExclusive - 1)\n            });\n            return this.provider.send(\"eth_getLogs\", [\n                rangeFilter\n            ]);\n        });\n    }\n}\nfunction $ad2c604ba644dcfb$var$toNewHeadsEvent(head) {\n    const result = Object.assign({}, head);\n    delete result.totalDifficulty;\n    delete result.transactions;\n    delete result.uncles;\n    return result;\n}\nfunction $ad2c604ba644dcfb$var$dedupeNewHeads(events) {\n    return $ad2c604ba644dcfb$var$dedupe(events, (event)=>event.hash);\n}\nfunction $ad2c604ba644dcfb$var$dedupeLogs(events) {\n    return $ad2c604ba644dcfb$var$dedupe(events, (event)=>`${event.blockHash}/${event.logIndex}`);\n}\nfunction $ad2c604ba644dcfb$var$dedupe(items, getKey) {\n    const keysSeen = new Set();\n    const result = [];\n    items.forEach((item)=>{\n        const key = getKey(item);\n        if (!keysSeen.has(key)) {\n            keysSeen.add(key);\n            result.push(item);\n        }\n    });\n    return result;\n}\nconst $ad2c604ba644dcfb$var$CANCELLED = new Error(\"Cancelled\");\nfunction $ad2c604ba644dcfb$var$throwIfCancelled(isCancelled) {\n    if (isCancelled()) throw $ad2c604ba644dcfb$var$CANCELLED;\n}\nconst $ad2c604ba644dcfb$var$HEARTBEAT_INTERVAL = 30000;\nconst $ad2c604ba644dcfb$var$HEARTBEAT_WAIT_TIME = 10000;\nconst $ad2c604ba644dcfb$var$BACKFILL_TIMEOUT = 60000;\nconst $ad2c604ba644dcfb$var$BACKFILL_RETRIES = 5;\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */ const $ad2c604ba644dcfb$var$RETAINED_EVENT_BLOCK_COUNT = 10;\n/**\r\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\r\n *\r\n * @public\r\n */ class $ad2c604ba644dcfb$export$f6c13301c7b76371 extends (0, $i7Wzi.WebSocketProvider) {\n    /** @internal */ constructor(config, wsConstructor){\n        var _a;\n        // Normalize the API Key to a string.\n        const apiKey = (0, $bq21X.AlchemyProvider).getApiKey(config.apiKey);\n        // Generate our own connection info with the correct endpoint URLs.\n        const alchemyNetwork = (0, $bq21X.AlchemyProvider).getAlchemyNetwork(config.network);\n        const connection = (0, $bq21X.AlchemyProvider).getAlchemyConnectionInfo(alchemyNetwork, apiKey, \"wss\");\n        const protocol = `alchemy-sdk-${(0, $07xSV.V)}`;\n        // Use the provided config URL override if it exists, otherwise use the created one.\n        const ws = new (0, (/*@__PURE__*/$parcel$interopDefault($5R2ui)))((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {\n            wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : $ad2c604ba644dcfb$var$getWebsocketConstructor()\n        });\n        // Normalize the Alchemy named network input to the network names used by\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\n        // correctly set the network.\n        const ethersNetwork = (0, $07xSV.E)[alchemyNetwork];\n        super(ws, ethersNetwork);\n        this._events = [];\n        // In the case of a WebSocket reconnection, all subscriptions are lost and we\n        // create new ones to replace them, but we want to create the illusion that\n        // the original subscriptions persist. Thus, maintain a mapping from the\n        // \"virtual\" subscription ids which are visible to the consumer to the\n        // \"physical\" subscription ids of the actual connections. This terminology is\n        // borrowed from virtual and physical memory, which has a similar mapping.\n        /** @internal */ this.virtualSubscriptionsById = new Map();\n        /** @internal */ this.virtualIdsByPhysicalId = new Map();\n        /**\r\n         * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n         * messages. To allow backfilling, track all messages that are emitted.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */ this.handleMessage = (event)=>{\n            const message = JSON.parse(event.data);\n            if (!$ad2c604ba644dcfb$var$isSubscriptionEvent(message)) return;\n            const physicalId = message.params.subscription;\n            const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n            if (!virtualId) return;\n            const subscription = this.virtualSubscriptionsById.get(virtualId);\n            if (subscription.method !== \"eth_subscribe\") return;\n            switch(subscription.params[0]){\n                case \"newHeads\":\n                    {\n                        const newHeadsSubscription = subscription;\n                        const newHeadsMessage = message;\n                        const { isBackfilling: isBackfilling, backfillBuffer: backfillBuffer } = newHeadsSubscription;\n                        const { result: result } = newHeadsMessage.params;\n                        if (isBackfilling) $ad2c604ba644dcfb$var$addToNewHeadsEventsBuffer(backfillBuffer, result);\n                        else if (physicalId !== virtualId) // In the case of a re-opened subscription, ethers will not emit the\n                        // event, so the SDK has to.\n                        this.emitAndRememberEvent(virtualId, result, $ad2c604ba644dcfb$var$getNewHeadsBlockNumber);\n                        else // Ethers subscription mapping will emit the event, just store it.\n                        this.rememberEvent(virtualId, result, $ad2c604ba644dcfb$var$getNewHeadsBlockNumber);\n                        break;\n                    }\n                case \"logs\":\n                    {\n                        const logsSubscription = subscription;\n                        const logsMessage = message;\n                        const { isBackfilling: isBackfilling, backfillBuffer: backfillBuffer } = logsSubscription;\n                        const { result: result } = logsMessage.params;\n                        if (isBackfilling) $ad2c604ba644dcfb$var$addToLogsEventsBuffer(backfillBuffer, result);\n                        else if (virtualId !== physicalId) this.emitAndRememberEvent(virtualId, result, $ad2c604ba644dcfb$var$getLogsBlockNumber);\n                        else this.rememberEvent(virtualId, result, $ad2c604ba644dcfb$var$getLogsBlockNumber);\n                        break;\n                    }\n                default:\n                    if (physicalId !== virtualId) {\n                        // In the case of a re-opened subscription, ethers will not emit the\n                        // event, so the SDK has to.\n                        const { result: result } = message.params;\n                        this.emitEvent(virtualId, result);\n                    }\n            }\n        };\n        /**\r\n         * When the websocket connection reopens:\r\n         *\r\n         * 1. Resubscribe to all existing subscriptions and start backfilling\r\n         * 2. Restart heart beat.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */ this.handleReopen = ()=>{\n            this.virtualIdsByPhysicalId.clear();\n            const { cancel: cancel, isCancelled: isCancelled } = $ad2c604ba644dcfb$var$makeCancelToken();\n            this.cancelBackfill = cancel;\n            for (const subscription of this.virtualSubscriptionsById.values())(()=>(0, $07xSV._)(this, void 0, void 0, function*() {\n                    try {\n                        yield this.resubscribeAndBackfill(isCancelled, subscription);\n                    } catch (error) {\n                        if (!isCancelled()) console.error(`Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`, error);\n                    }\n                }))();\n            this.startHeartbeat();\n        };\n        /**\r\n         * Cancels the heartbeat and any pending backfills being performed. This is\r\n         * called when the websocket connection goes down or is disconnected.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */ this.stopHeartbeatAndBackfill = ()=>{\n            if (this.heartbeatIntervalId != null) {\n                clearInterval(this.heartbeatIntervalId);\n                this.heartbeatIntervalId = undefined;\n            }\n            this.cancelBackfill();\n        };\n        this.apiKey = apiKey;\n        // Start heartbeat and backfiller for the websocket connection.\n        this.backfiller = new $ad2c604ba644dcfb$var$WebsocketBackfiller(this);\n        this.addSocketListeners();\n        this.startHeartbeat();\n        this.cancelBackfill = (0, $07xSV.n);\n    }\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ static getNetwork(network) {\n        if (typeof network === \"string\" && network in (0, $07xSV.C)) return (0, $07xSV.C)[network];\n        // Call the standard ethers.js getNetwork method for other networks.\n        return (0, $kYIxw.getNetwork)(network);\n    }\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based subscriptions.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */ // TODO: Override `Listener` type to get type autocompletions.\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based\r\n     * subscriptions. Adds a listener to the triggered for only the next\r\n     * {@link eventName} event, after which it will be removed.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */ // TODO: Override `Listener` type to get type autocompletions.\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName Event to unlisten to.\r\n     * @param listener The listener function to remove.\r\n     * @override\r\n     * @public\r\n     */ off(eventName, listener) {\n        if ((0, $07xSV.i)(eventName)) return this._off(eventName, listener);\n        else return super.off(eventName, listener);\n    }\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @override\r\n     * @public\r\n     */ removeAllListeners(eventName) {\n        if (eventName !== undefined && (0, $07xSV.i)(eventName)) return this._removeAllListeners(eventName);\n        else return super.removeAllListeners(eventName);\n    }\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     * @override\r\n     */ listenerCount(eventName) {\n        if (eventName !== undefined && (0, $07xSV.i)(eventName)) return this._listenerCount(eventName);\n        else return super.listenerCount(eventName);\n    }\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     * @public\r\n     * @override\r\n     */ listeners(eventName) {\n        if (eventName !== undefined && (0, $07xSV.i)(eventName)) return this._listeners(eventName);\n        else return super.listeners(eventName);\n    }\n    /**\r\n     * Overrides the method in `BaseProvider` in order to properly format the\r\n     * Alchemy subscription events.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ _addEventListener(eventName, listener, once) {\n        if ((0, $07xSV.i)(eventName)) {\n            (0, $07xSV.v)(eventName);\n            const event = new (0, $07xSV.c)((0, $07xSV.e)(eventName), listener, once);\n            this._events.push(event);\n            this._startEvent(event);\n            return this;\n        } else return super._addEventListener(eventName, listener, once);\n    }\n    /**\r\n     * Overrides the `_startEvent()` method in ethers.js's\r\n     * {@link WebSocketProvider} to include additional alchemy methods.\r\n     *\r\n     * @param event\r\n     * @override\r\n     * @internal\r\n     */ _startEvent(event) {\n        // Check if the event type is a custom Alchemy subscription.\n        const customLogicTypes = [\n            ...(0, $07xSV.A),\n            \"block\",\n            \"filter\"\n        ];\n        if (customLogicTypes.includes(event.type)) this.customStartEvent(event);\n        else super._startEvent(event);\n    }\n    /**\r\n     * Overridden from ethers.js's {@link WebSocketProvider}\r\n     *\r\n     * Modified in order to add mappings for backfilling.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ _subscribe(tag, param, processFunc, event) {\n        return (0, $07xSV._)(this, void 0, void 0, function*() {\n            let subIdPromise = this._subIds[tag];\n            // BEGIN MODIFIED CODE\n            const startingBlockNumber = yield this.getBlockNumber();\n            // END MODIFIED CODE\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param)=>{\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            // BEGIN MODIFIED CODE\n            const resolvedParams = yield Promise.all(param);\n            this.virtualSubscriptionsById.set(subId, {\n                event: event,\n                method: \"eth_subscribe\",\n                params: resolvedParams,\n                startingBlockNumber: startingBlockNumber,\n                virtualId: subId,\n                physicalId: subId,\n                sentEvents: [],\n                isBackfilling: false,\n                backfillBuffer: []\n            });\n            this.virtualIdsByPhysicalId.set(subId, subId);\n            // END MODIFIED CODE\n            this._subs[subId] = {\n                tag: tag,\n                processFunc: processFunc\n            };\n        });\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */ emit(eventName, ...args) {\n        if ((0, $07xSV.i)(eventName)) {\n            let result = false;\n            const stopped = [];\n            // This line is the only modified line from the original method.\n            const eventTag = (0, $07xSV.e)(eventName);\n            this._events = this._events.filter((event)=>{\n                if (event.tag !== eventTag) return true;\n                setTimeout(()=>{\n                    event.listener.apply(this, args);\n                }, 0);\n                result = true;\n                if (event.once) {\n                    stopped.push(event);\n                    return false;\n                }\n                return true;\n            });\n            stopped.forEach((event)=>{\n                this._stopEvent(event);\n            });\n            return result;\n        } else return super.emit(eventName, ...args);\n    }\n    /** @internal */ sendBatch(parts) {\n        return (0, $07xSV._)(this, void 0, void 0, function*() {\n            let nextId = 0;\n            const payload = parts.map(({ method: method, params: params })=>{\n                return {\n                    method: method,\n                    params: params,\n                    jsonrpc: \"2.0\",\n                    id: `alchemy-sdk:${nextId++}`\n                };\n            });\n            return this.sendBatchConcurrently(payload);\n        });\n    }\n    /** @override */ destroy() {\n        this.removeSocketListeners();\n        this.stopHeartbeatAndBackfill();\n        return super.destroy();\n    }\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */ isCommunityResource() {\n        return this.apiKey === (0, $07xSV.D);\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\r\n     *\r\n     * This method is copied over directly in order to support Alchemy's\r\n     * subscription type by allowing the provider to properly stop Alchemy's\r\n     * subscription events.\r\n     *\r\n     * @internal\r\n     */ _stopEvent(event) {\n        let tag = event.tag;\n        // START MODIFIED CODE\n        if ((0, $07xSV.A).includes(event.type)) {\n            // There are remaining pending transaction listeners.\n            if (this._events.filter((e)=>(0, $07xSV.A).includes(e.type)).length) return;\n        // END MODIFIED CODE\n        } else if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e)=>e.type === \"tx\").length) return;\n            tag = \"tx\";\n        } else if (this.listenerCount(event.event)) // There are remaining event listeners\n        return;\n        const subId = this._subIds[tag];\n        if (!subId) return;\n        delete this._subIds[tag];\n        subId.then((subId)=>{\n            if (!this._subs[subId]) return;\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [\n                subId\n            ]);\n        });\n    }\n    /** @internal */ addSocketListeners() {\n        this._websocket.addEventListener(\"message\", this.handleMessage);\n        this._websocket.addEventListener(\"reopen\", this.handleReopen);\n        this._websocket.addEventListener(\"down\", this.stopHeartbeatAndBackfill);\n    }\n    /** @internal */ removeSocketListeners() {\n        this._websocket.removeEventListener(\"message\", this.handleMessage);\n        this._websocket.removeEventListener(\"reopen\", this.handleReopen);\n        this._websocket.removeEventListener(\"down\", this.stopHeartbeatAndBackfill);\n    }\n    /**\r\n     * Reopens the backfill based on\r\n     *\r\n     * @param isCancelled\r\n     * @param subscription\r\n     * @internal\r\n     */ resubscribeAndBackfill(isCancelled, subscription) {\n        return (0, $07xSV._)(this, void 0, void 0, function*() {\n            const { virtualId: virtualId, method: method, params: params, sentEvents: sentEvents, backfillBuffer: backfillBuffer, startingBlockNumber: startingBlockNumber } = subscription;\n            subscription.isBackfilling = true;\n            backfillBuffer.length = 0;\n            try {\n                const physicalId = yield this.send(method, params);\n                $ad2c604ba644dcfb$var$throwIfCancelled(isCancelled);\n                subscription.physicalId = physicalId;\n                this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n                switch(params[0]){\n                    case \"newHeads\":\n                        {\n                            const backfillEvents = yield $ad2c604ba644dcfb$var$withBackoffRetries(()=>$ad2c604ba644dcfb$var$withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), $ad2c604ba644dcfb$var$BACKFILL_TIMEOUT), $ad2c604ba644dcfb$var$BACKFILL_RETRIES, ()=>!isCancelled());\n                            $ad2c604ba644dcfb$var$throwIfCancelled(isCancelled);\n                            const events = $ad2c604ba644dcfb$var$dedupeNewHeads([\n                                ...backfillEvents,\n                                ...backfillBuffer\n                            ]);\n                            events.forEach((event)=>this.emitNewHeadsEvent(virtualId, event));\n                            break;\n                        }\n                    case \"logs\":\n                        {\n                            const filter = params[1] || {};\n                            const backfillEvents = yield $ad2c604ba644dcfb$var$withBackoffRetries(()=>$ad2c604ba644dcfb$var$withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), $ad2c604ba644dcfb$var$BACKFILL_TIMEOUT), $ad2c604ba644dcfb$var$BACKFILL_RETRIES, ()=>!isCancelled());\n                            $ad2c604ba644dcfb$var$throwIfCancelled(isCancelled);\n                            const events = $ad2c604ba644dcfb$var$dedupeLogs([\n                                ...backfillEvents,\n                                ...backfillBuffer\n                            ]);\n                            events.forEach((event)=>this.emitLogsEvent(virtualId, event));\n                            break;\n                        }\n                    default:\n                        break;\n                }\n            } finally{\n                subscription.isBackfilling = false;\n                backfillBuffer.length = 0;\n            }\n        });\n    }\n    /** @internal */ emitNewHeadsEvent(virtualId, result) {\n        this.emitAndRememberEvent(virtualId, result, $ad2c604ba644dcfb$var$getNewHeadsBlockNumber);\n    }\n    /** @internal */ emitLogsEvent(virtualId, result) {\n        this.emitAndRememberEvent(virtualId, result, $ad2c604ba644dcfb$var$getLogsBlockNumber);\n    }\n    /**\r\n     * Emits an event to consumers, but also remembers it in its subscriptions's\r\n     * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n     * and needs to be reconnected.\r\n     *\r\n     * @internal\r\n     */ emitAndRememberEvent(virtualId, result, getBlockNumber) {\n        this.rememberEvent(virtualId, result, getBlockNumber);\n        this.emitEvent(virtualId, result);\n    }\n    emitEvent(virtualId, result) {\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\n        if (!subscription) return;\n        this.emitGenericEvent(subscription, result);\n    }\n    /** @internal */ rememberEvent(virtualId, result, getBlockNumber) {\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\n        if (!subscription) return;\n        // Web3 modifies these event objects once we pass them on (changing hex\n        // numbers to numbers). We want the original event, so make a defensive\n        // copy.\n        $ad2c604ba644dcfb$var$addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\n    }\n    /** @internal */ emitGenericEvent(subscription, result) {\n        const emitFunction = this.emitProcessFn(subscription.event);\n        emitFunction(result);\n    }\n    /**\r\n     * Starts a heartbeat that pings the websocket server periodically to ensure\r\n     * that the connection stays open.\r\n     *\r\n     * @internal\r\n     */ startHeartbeat() {\n        if (this.heartbeatIntervalId != null) return;\n        this.heartbeatIntervalId = setInterval(()=>(0, $07xSV._)(this, void 0, void 0, function*() {\n                try {\n                    yield $ad2c604ba644dcfb$var$withTimeout(this.send(\"net_version\"), $ad2c604ba644dcfb$var$HEARTBEAT_WAIT_TIME);\n                } catch (_a) {\n                    this._websocket.reconnect();\n                }\n            }), $ad2c604ba644dcfb$var$HEARTBEAT_INTERVAL);\n    }\n    /**\r\n     * This method sends the batch concurrently as individual requests rather than\r\n     * as a batch, which was the original implementation. The original batch logic\r\n     * is preserved in this implementation in order for faster porting.\r\n     *\r\n     * @param payload\r\n     * @internal\r\n     */ // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n    // TODO(errors): Use allSettled() once we have more error handling.\n    sendBatchConcurrently(payload) {\n        return (0, $07xSV._)(this, void 0, void 0, function*() {\n            return Promise.all(payload.map((req)=>this.send(req.method, req.params)));\n        });\n    }\n    /** @internal */ customStartEvent(event) {\n        if (event.type === (0, $07xSV.h)) {\n            const { fromAddress: fromAddress, toAddress: toAddress, hashesOnly: hashesOnly } = event;\n            this._subscribe(event.tag, [\n                (0, $07xSV.j).PENDING_TRANSACTIONS,\n                {\n                    fromAddress: fromAddress,\n                    toAddress: toAddress,\n                    hashesOnly: hashesOnly\n                }\n            ], this.emitProcessFn(event), event);\n        } else if (event.type === (0, $07xSV.k)) {\n            const { addresses: addresses, includeRemoved: includeRemoved, hashesOnly: hashesOnly } = event;\n            this._subscribe(event.tag, [\n                (0, $07xSV.j).MINED_TRANSACTIONS,\n                {\n                    addresses: addresses,\n                    includeRemoved: includeRemoved,\n                    hashesOnly: hashesOnly\n                }\n            ], this.emitProcessFn(event), event);\n        } else if (event.type === \"block\") this._subscribe(\"block\", [\n            \"newHeads\"\n        ], this.emitProcessFn(event), event);\n        else if (event.type === \"filter\") this._subscribe(event.tag, [\n            \"logs\",\n            this._getFilter(event.filter)\n        ], this.emitProcessFn(event), event);\n    }\n    /** @internal */ emitProcessFn(event) {\n        switch(event.type){\n            case 0, $07xSV.h:\n                return (result)=>this.emit({\n                        method: (0, $07xSV.j).PENDING_TRANSACTIONS,\n                        fromAddress: event.fromAddress,\n                        toAddress: event.toAddress,\n                        hashesOnly: event.hashesOnly\n                    }, result);\n            case 0, $07xSV.k:\n                return (result)=>this.emit({\n                        method: (0, $07xSV.j).MINED_TRANSACTIONS,\n                        addresses: event.addresses,\n                        includeRemoved: event.includeRemoved,\n                        hashesOnly: event.hashesOnly\n                    }, result);\n            case \"block\":\n                return (result)=>{\n                    const blockNumber = (0, $3HDBd.BigNumber).from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                };\n            case \"filter\":\n                return (result)=>{\n                    if (result.removed == null) result.removed = false;\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                };\n            default:\n                throw new Error(\"Invalid event type to `emitProcessFn()`\");\n        }\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.off()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */ _off(eventName, listener) {\n        if (listener == null) return this.removeAllListeners(eventName);\n        const stopped = [];\n        let found = false;\n        const eventTag = (0, $07xSV.e)(eventName);\n        this._events = this._events.filter((event)=>{\n            if (event.tag !== eventTag || event.listener != listener) return true;\n            if (found) return true;\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return this;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */ _removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        } else {\n            const eventTag = (0, $07xSV.e)(eventName);\n            this._events = this._events.filter((event)=>{\n                if (event.tag !== eventTag) return true;\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event)=>{\n            this._stopEvent(event);\n        });\n        return this;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */ _listenerCount(eventName) {\n        if (!eventName) return this._events.length;\n        const eventTag = (0, $07xSV.e)(eventName);\n        return this._events.filter((event)=>{\n            return event.tag === eventTag;\n        }).length;\n    }\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */ _listeners(eventName) {\n        if (eventName == null) return this._events.map((event)=>event.listener);\n        const eventTag = (0, $07xSV.e)(eventName);\n        return this._events.filter((event)=>event.tag === eventTag).map((event)=>event.listener);\n    }\n}\n\nfunction $ad2c604ba644dcfb$var$getWebsocketConstructor() {\n    return $ad2c604ba644dcfb$var$isNodeEnvironment() ? (parcelRequire(\"9RaPq\")).w3cwebsocket : WebSocket;\n}\nfunction $ad2c604ba644dcfb$var$isNodeEnvironment() {\n    return typeof $ibaza !== \"undefined\" && $ibaza != null && $ibaza.versions != null && $ibaza.versions.node != null;\n}\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction $ad2c604ba644dcfb$var$makeCancelToken() {\n    let cancelled = false;\n    return {\n        cancel: ()=>cancelled = true,\n        isCancelled: ()=>cancelled\n    };\n}\n// TODO(cleanup): replace with SDK's backoff implementation\nconst $ad2c604ba644dcfb$var$MIN_RETRY_DELAY = 1000;\nconst $ad2c604ba644dcfb$var$RETRY_BACKOFF_FACTOR = 2;\nconst $ad2c604ba644dcfb$var$MAX_RETRY_DELAY = 30000;\nfunction $ad2c604ba644dcfb$var$withBackoffRetries(f, retryCount, shouldRetry = ()=>true) {\n    return (0, $07xSV._)(this, void 0, void 0, function*() {\n        let nextWaitTime = 0;\n        let i = 0;\n        while(true)try {\n            return yield f();\n        } catch (error) {\n            i++;\n            if (i >= retryCount || !shouldRetry(error)) throw error;\n            yield $ad2c604ba644dcfb$var$delay(nextWaitTime);\n            if (!shouldRetry(error)) throw error;\n            nextWaitTime = nextWaitTime === 0 ? $ad2c604ba644dcfb$var$MIN_RETRY_DELAY : Math.min($ad2c604ba644dcfb$var$MAX_RETRY_DELAY, $ad2c604ba644dcfb$var$RETRY_BACKOFF_FACTOR * nextWaitTime);\n        }\n    });\n}\nfunction $ad2c604ba644dcfb$var$delay(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\nfunction $ad2c604ba644dcfb$var$withTimeout(promise, ms) {\n    return Promise.race([\n        promise,\n        new Promise((_, reject)=>setTimeout(()=>reject(new Error(\"Timeout\")), ms))\n    ]);\n}\nfunction $ad2c604ba644dcfb$var$getNewHeadsBlockNumber(event) {\n    return (0, $07xSV.f)(event.number);\n}\nfunction $ad2c604ba644dcfb$var$getLogsBlockNumber(event) {\n    return (0, $07xSV.f)(event.blockNumber);\n}\nfunction $ad2c604ba644dcfb$var$isResponse(message) {\n    return Array.isArray(message) || message.jsonrpc === \"2.0\" && message.id !== undefined;\n}\nfunction $ad2c604ba644dcfb$var$isSubscriptionEvent(message) {\n    return !$ad2c604ba644dcfb$var$isResponse(message);\n}\nfunction $ad2c604ba644dcfb$var$addToNewHeadsEventsBuffer(pastEvents, event) {\n    $ad2c604ba644dcfb$var$addToPastEventsBuffer(pastEvents, event, $ad2c604ba644dcfb$var$getNewHeadsBlockNumber);\n}\nfunction $ad2c604ba644dcfb$var$addToLogsEventsBuffer(pastEvents, event) {\n    $ad2c604ba644dcfb$var$addToPastEventsBuffer(pastEvents, event, $ad2c604ba644dcfb$var$getLogsBlockNumber);\n}\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */ function $ad2c604ba644dcfb$var$addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\n    const currentBlockNumber = getBlockNumber(event);\n    // Find first index of an event recent enough to retain, then drop everything\n    // at a lower index.\n    const firstGoodIndex = pastEvents.findIndex((e)=>getBlockNumber(e) > currentBlockNumber - $ad2c604ba644dcfb$var$RETAINED_EVENT_BLOCK_COUNT);\n    if (firstGoodIndex === -1) pastEvents.length = 0;\n    else pastEvents.splice(0, firstGoodIndex);\n    pastEvents.push(event);\n}\n\n});\nparcelRegister(\"5R2ui\", function(module, exports) {\n\"use strict\";\nObject.defineProperty(module.exports, \"__esModule\", {\n    value: true\n});\nvar $4433d4fff50a186a$var$SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar $4433d4fff50a186a$var$SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar $4433d4fff50a186a$var$SturdyWebSocket = /** @class */ function() {\n    function SturdyWebSocket(url, protocolsOrOptions, options) {\n        if (options === void 0) options = {};\n        this.url = url;\n        this.onclose = null;\n        this.onerror = null;\n        this.onmessage = null;\n        this.onopen = null;\n        this.ondown = null;\n        this.onreopen = null;\n        this.CONNECTING = SturdyWebSocket.CONNECTING;\n        this.OPEN = SturdyWebSocket.OPEN;\n        this.CLOSING = SturdyWebSocket.CLOSING;\n        this.CLOSED = SturdyWebSocket.CLOSED;\n        this.hasBeenOpened = false;\n        this.isClosed = false;\n        this.messageBuffer = [];\n        this.nextRetryTime = 0;\n        this.reconnectCount = 0;\n        this.lastKnownExtensions = \"\";\n        this.lastKnownProtocol = \"\";\n        this.listeners = {};\n        if (protocolsOrOptions == null || typeof protocolsOrOptions === \"string\" || Array.isArray(protocolsOrOptions)) this.protocols = protocolsOrOptions;\n        else options = protocolsOrOptions;\n        this.options = $4433d4fff50a186a$var$applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") this.options.wsConstructor = WebSocket;\n            else throw new Error(\"WebSocket not present in global scope and no wsConstructor option was provided.\");\n        }\n        this.openNewWebSocket();\n    }\n    Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n        get: function() {\n            return this.binaryTypeInternal || \"blob\";\n        },\n        set: function(binaryType) {\n            this.binaryTypeInternal = binaryType;\n            if (this.ws) this.ws.binaryType = binaryType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n        get: function() {\n            var sum = this.ws ? this.ws.bufferedAmount : 0;\n            var hasUnknownAmount = false;\n            this.messageBuffer.forEach(function(data) {\n                var byteLength = $4433d4fff50a186a$var$getDataByteLength(data);\n                if (byteLength != null) sum += byteLength;\n                else hasUnknownAmount = true;\n            });\n            if (hasUnknownAmount) this.debugLog(\"Some buffered data had unknown length. bufferedAmount() return value may be below the correct amount.\");\n            return sum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n        get: function() {\n            return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n        get: function() {\n            return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n        get: function() {\n            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SturdyWebSocket.prototype.close = function(code, reason) {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    };\n    SturdyWebSocket.prototype.send = function(data) {\n        if (this.isClosed) throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        else if (this.ws && this.ws.readyState === this.OPEN) this.ws.send(data);\n        else this.messageBuffer.push(data);\n    };\n    SturdyWebSocket.prototype.reconnect = function() {\n        if (this.isClosed) throw new Error(\"Cannot call reconnect() on socket which is permanently closed.\");\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    };\n    SturdyWebSocket.prototype.addEventListener = function(type, listener) {\n        if (!this.listeners[type]) this.listeners[type] = [];\n        this.listeners[type].push(listener);\n    };\n    SturdyWebSocket.prototype.dispatchEvent = function(event) {\n        return this.dispatchEventOfType(event.type, event);\n    };\n    SturdyWebSocket.prototype.removeEventListener = function(type, listener) {\n        if (this.listeners[type]) this.listeners[type] = this.listeners[type].filter(function(l) {\n            return l !== listener;\n        });\n    };\n    SturdyWebSocket.prototype.openNewWebSocket = function() {\n        var _this = this;\n        if (this.isClosed) return;\n        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;\n        this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n        var ws = new wsConstructor(this.url, this.protocols);\n        ws.onclose = function(event) {\n            return _this.handleClose(event);\n        };\n        ws.onerror = function(event) {\n            return _this.handleError(event);\n        };\n        ws.onmessage = function(event) {\n            return _this.handleMessage(event);\n        };\n        ws.onopen = function(event) {\n            return _this.handleOpen(event);\n        };\n        this.connectTimeoutId = setTimeout(function() {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            _this.clearConnectTimeout();\n            _this.disposeSocket();\n            _this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    };\n    SturdyWebSocket.prototype.handleOpen = function(event) {\n        var _this = this;\n        if (!this.ws || this.isClosed) return;\n        var allClearResetTime = this.options.allClearResetTime;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) this.ws.binaryType = this.binaryTypeInternal;\n        else this.binaryTypeInternal = this.ws.binaryType;\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) this.dispatchEventOfType(\"reopen\", event);\n        else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(function(message) {\n            return _this.send(message);\n        });\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(function() {\n            _this.clearAllClearTimeout();\n            _this.nextRetryTime = 0;\n            _this.reconnectCount = 0;\n            var openTime = allClearResetTime / 1000 | 0;\n            _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" + \" retry time and count.\");\n        }, allClearResetTime);\n    };\n    SturdyWebSocket.prototype.handleMessage = function(event) {\n        if (this.isClosed) return;\n        this.dispatchEventOfType(\"message\", event);\n    };\n    SturdyWebSocket.prototype.handleClose = function(event) {\n        var _this = this;\n        if (this.isClosed) return;\n        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n            return;\n        }\n        var willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") this.handleWillReconnect(willReconnect, event, $4433d4fff50a186a$var$SHOULD_RECONNECT_FALSE_MESSAGE);\n        else willReconnect.then(function(willReconnectResolved) {\n            if (_this.isClosed) return;\n            _this.handleWillReconnect(willReconnectResolved, event, $4433d4fff50a186a$var$SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n        });\n    };\n    SturdyWebSocket.prototype.handleError = function(event) {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    };\n    SturdyWebSocket.prototype.handleWillReconnect = function(willReconnect, event, denialReason) {\n        if (willReconnect) this.reestablishConnection();\n        else this.stopReconnecting(event, denialReason);\n    };\n    SturdyWebSocket.prototype.reestablishConnection = function() {\n        var _this = this;\n        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;\n        this.reconnectCount++;\n        var retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n        setTimeout(function() {\n            return _this.openNewWebSocket();\n        }, retryTime);\n        var retryTimeSeconds = retryTime / 1000 | 0;\n        this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n    };\n    SturdyWebSocket.prototype.stopReconnecting = function(event, debugReason) {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) this.dispatchEventOfType(\"close\", event);\n    };\n    SturdyWebSocket.prototype.shutdown = function() {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    };\n    SturdyWebSocket.prototype.disposeSocket = function(closeCode, reason) {\n        if (!this.ws) return;\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = $4433d4fff50a186a$var$noop;\n        this.ws.onclose = $4433d4fff50a186a$var$noop;\n        this.ws.onmessage = $4433d4fff50a186a$var$noop;\n        this.ws.onopen = $4433d4fff50a186a$var$noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    };\n    SturdyWebSocket.prototype.clearAllTimeouts = function() {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    };\n    SturdyWebSocket.prototype.clearConnectTimeout = function() {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.clearAllClearTimeout = function() {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.dispatchEventOfType = function(type, event) {\n        var _this = this;\n        switch(type){\n            case \"close\":\n                if (this.onclose) this.onclose(event);\n                break;\n            case \"error\":\n                if (this.onerror) this.onerror(event);\n                break;\n            case \"message\":\n                if (this.onmessage) this.onmessage(event);\n                break;\n            case \"open\":\n                if (this.onopen) this.onopen(event);\n                break;\n            case \"down\":\n                if (this.ondown) this.ondown(event);\n                break;\n            case \"reopen\":\n                if (this.onreopen) this.onreopen(event);\n                break;\n        }\n        if (type in this.listeners) this.listeners[type].slice().forEach(function(listener) {\n            return _this.callListener(listener, event);\n        });\n        return !event || !event.defaultPrevented;\n    };\n    SturdyWebSocket.prototype.callListener = function(listener, event) {\n        if (typeof listener === \"function\") listener.call(this, event);\n        else listener.handleEvent.call(this, event);\n    };\n    SturdyWebSocket.prototype.debugLog = function(message) {\n        if (this.options.debug) // tslint:disable-next-line:no-console\n        console.log(message);\n    };\n    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function() {\n        var maxReconnectAttempts = this.options.maxReconnectAttempts;\n        return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + $4433d4fff50a186a$var$pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n    };\n    SturdyWebSocket.DEFAULT_OPTIONS = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: function() {\n            return true;\n        },\n        wsConstructor: undefined\n    };\n    SturdyWebSocket.CONNECTING = 0;\n    SturdyWebSocket.OPEN = 1;\n    SturdyWebSocket.CLOSING = 2;\n    SturdyWebSocket.CLOSED = 3;\n    return SturdyWebSocket;\n}();\nmodule.exports.default = $4433d4fff50a186a$var$SturdyWebSocket;\nfunction $4433d4fff50a186a$var$applyDefaultOptions(options) {\n    var result = {};\n    Object.keys($4433d4fff50a186a$var$SturdyWebSocket.DEFAULT_OPTIONS).forEach(function(key) {\n        var value = options[key];\n        result[key] = value === undefined ? $4433d4fff50a186a$var$SturdyWebSocket.DEFAULT_OPTIONS[key] : value;\n    });\n    return result;\n}\nfunction $4433d4fff50a186a$var$getDataByteLength(data) {\n    if (typeof data === \"string\") // UTF-16 strings use two bytes per character.\n    return 2 * data.length;\n    else if (data instanceof ArrayBuffer) return data.byteLength;\n    else if (data instanceof Blob) return data.size;\n    else return undefined;\n}\nfunction $4433d4fff50a186a$var$pluralize(s, n) {\n    return n === 1 ? s : s + \"s\";\n}\nfunction $4433d4fff50a186a$var$noop() {\n// Nothing.\n}\n\n});\n\n\n})();\n//# sourceMappingURL=alchemy-websocket-provider-a2f83072.b413acec.js.map\n","import { _ as __awaiter, f as fromHex, t as toHex, n as noop, C as CustomNetworks, i as isAlchemyEvent, v as verifyAlchemyEventName, c as EthersEvent, e as getAlchemyEventTag, D as DEFAULT_ALCHEMY_API_KEY, A as ALCHEMY_EVENT_TYPES, h as ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE, j as AlchemySubscription, k as ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE, V as VERSION, E as EthersNetwork } from './index-03ad9998.js';\nimport SturdyWebSocket from 'sturdy-websocket';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { getNetwork } from '@ethersproject/networks';\nimport { WebSocketProvider } from '@ethersproject/providers';\nimport { AlchemyProvider } from './alchemy-provider-033c5719.js';\nimport './api/utils';\nimport 'axios';\nimport '@ethersproject/abstract-provider';\nimport '@ethersproject/wallet';\nimport '@ethersproject/contracts';\nimport '@ethersproject/web';\n\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */\r\nconst MAX_BACKFILL_BLOCKS = 120;\r\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */\r\nclass WebsocketBackfiller {\r\n    constructor(provider) {\r\n        this.provider = provider;\r\n        // TODO: Use HTTP provider to do backfill.\r\n        this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\r\n    }\r\n    /**\r\n     * Runs backfill for `newHeads` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param previousHeads Previous head requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     * @returns A list of `newHeads` events that were sent since the last backfill.\r\n     */\r\n    getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous heads to fetch, return new heads since\r\n            // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\r\n            if (previousHeads.length === 0) {\r\n                return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted event is too far back in the past, there's no need\r\n            // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\r\n            // new heads.\r\n            const lastSeenBlockNumber = fromHex(previousHeads[previousHeads.length - 1].number);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber <= minBlockNumber) {\r\n                return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // To capture all `newHeads` events, return all head events from the last\r\n            // seen block number to current + any of the previous heads that were re-orged.\r\n            const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);\r\n            throwIfCancelled(isCancelled);\r\n            const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\r\n            throwIfCancelled(isCancelled);\r\n            return [...reorgHeads, ...intermediateHeads];\r\n        });\r\n    }\r\n    /**\r\n     * Runs backfill for `logs` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param filter The filter object that accompanies a logs subscription.\r\n     * @param previousLogs Previous log requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     */\r\n    getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous logs to fetch, return new logs since\r\n            // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\r\n            if (previousLogs.length === 0) {\r\n                return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted log is too far back in the past, there's no need\r\n            // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\r\n            // worth of logs.\r\n            const lastSeenBlockNumber = fromHex(previousLogs[previousLogs.length - 1].blockNumber);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber < minBlockNumber) {\r\n                return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // Return all log events that have happened along with log events that have\r\n            // been removed due to a chain reorg.\r\n            const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);\r\n            throwIfCancelled(isCancelled);\r\n            // All previous logs with a block number greater than the common ancestor\r\n            // were part of a re-org, so mark them as such.\r\n            const removedLogs = previousLogs\r\n                .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\r\n                .map(log => (Object.assign(Object.assign({}, log), { removed: true })));\r\n            // If no common ancestor was found, start backfill from the oldest log's\r\n            // block number.\r\n            const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\r\n                ? fromHex(previousLogs[0].blockNumber)\r\n                : commonAncestor.blockNumber;\r\n            let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\r\n            // De-dupe any logs that were already emitted.\r\n            addedLogs = addedLogs.filter(log => log &&\r\n                (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\r\n                    fromHex(log.logIndex) > commonAncestor.logIndex));\r\n            throwIfCancelled(isCancelled);\r\n            return [...removedLogs, ...addedLogs];\r\n        });\r\n    }\r\n    /**\r\n     * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */\r\n    setMaxBackfillBlock(newMax) {\r\n        this.maxBackfillBlocks = newMax;\r\n    }\r\n    /**\r\n     * Gets the current block number as a number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockNumber() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const blockNumberHex = yield this.provider.send('eth_blockNumber');\r\n            return fromHex(blockNumberHex);\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `newHead` events in the provided range. Note that the returned\r\n     * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n     * that were part of a re-org.\r\n     *\r\n     * @private\r\n     */\r\n    getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const batchParts = [];\r\n            for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\r\n                batchParts.push({\r\n                    method: 'eth_getBlockByNumber',\r\n                    params: [toHex(i), false]\r\n                });\r\n            }\r\n            // TODO: handle errors\r\n            const blockHeads = yield this.provider.sendBatch(batchParts);\r\n            return blockHeads.map(toNewHeadsEvent);\r\n        });\r\n    }\r\n    /**\r\n     * Returns all heads that were part of a reorg event.\r\n     *\r\n     * @private\r\n     */\r\n    getReorgHeads(isCancelled, previousHeads) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const result = [];\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            for (let i = previousHeads.length - 1; i >= 0; i--) {\r\n                const oldEvent = previousHeads[i];\r\n                const blockHead = yield this.getBlockByNumber(fromHex(oldEvent.number));\r\n                throwIfCancelled(isCancelled);\r\n                // If the hashes match, then current head in the iteration was not re-orged.\r\n                if (oldEvent.hash === blockHead.hash) {\r\n                    break;\r\n                }\r\n                result.push(toNewHeadsEvent(blockHead));\r\n            }\r\n            return result.reverse();\r\n        });\r\n    }\r\n    /**\r\n     * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n     * block information for the provided block number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockByNumber(blockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this.provider.send('eth_getBlockByNumber', [\r\n                toHex(blockNumber),\r\n                false\r\n            ]);\r\n        });\r\n    }\r\n    /**\r\n     * Given a list of previous log events, finds the common block number from the\r\n     * logs that matches the block head.\r\n     *\r\n     * This can be used to identify which logs are part of a re-org.\r\n     *\r\n     * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n     *\r\n     * @private\r\n     */\r\n    getCommonAncestor(isCancelled, previousLogs) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            let blockHead = yield this.getBlockByNumber(fromHex(previousLogs[previousLogs.length - 1].blockNumber));\r\n            throwIfCancelled(isCancelled);\r\n            for (let i = previousLogs.length - 1; i >= 0; i--) {\r\n                const oldLog = previousLogs[i];\r\n                // Ensure that updated blocks are fetched every time the log's block number\r\n                // changes.\r\n                if (oldLog.blockNumber !== blockHead.number) {\r\n                    blockHead = yield this.getBlockByNumber(fromHex(oldLog.blockNumber));\r\n                }\r\n                // Since logs are ordered in ascending order, the first log that matches\r\n                // the hash should be the largest logIndex.\r\n                if (oldLog.blockHash === blockHead.hash) {\r\n                    return {\r\n                        blockNumber: fromHex(oldLog.blockNumber),\r\n                        logIndex: fromHex(oldLog.logIndex)\r\n                    };\r\n                }\r\n            }\r\n            return {\r\n                blockNumber: Number.NEGATIVE_INFINITY,\r\n                logIndex: Number.NEGATIVE_INFINITY\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `logs` events in the provided range. Note that the returned logs\r\n     * do not include removed logs.\r\n     *\r\n     * @private\r\n     */ getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const rangeFilter = Object.assign(Object.assign({}, filter), { fromBlock: toHex(fromBlockInclusive), toBlock: toHex(toBlockExclusive - 1) });\r\n            return this.provider.send('eth_getLogs', [rangeFilter]);\r\n        });\r\n    }\r\n}\r\nfunction toNewHeadsEvent(head) {\r\n    const result = Object.assign({}, head);\r\n    delete result.totalDifficulty;\r\n    delete result.transactions;\r\n    delete result.uncles;\r\n    return result;\r\n}\r\nfunction dedupeNewHeads(events) {\r\n    return dedupe(events, event => event.hash);\r\n}\r\nfunction dedupeLogs(events) {\r\n    return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\r\n}\r\nfunction dedupe(items, getKey) {\r\n    const keysSeen = new Set();\r\n    const result = [];\r\n    items.forEach(item => {\r\n        const key = getKey(item);\r\n        if (!keysSeen.has(key)) {\r\n            keysSeen.add(key);\r\n            result.push(item);\r\n        }\r\n    });\r\n    return result;\r\n}\r\nconst CANCELLED = new Error('Cancelled');\r\nfunction throwIfCancelled(isCancelled) {\r\n    if (isCancelled()) {\r\n        throw CANCELLED;\r\n    }\r\n}\n\nconst HEARTBEAT_INTERVAL = 30000;\r\nconst HEARTBEAT_WAIT_TIME = 10000;\r\nconst BACKFILL_TIMEOUT = 60000;\r\nconst BACKFILL_RETRIES = 5;\r\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */\r\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\r\n/**\r\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyWebSocketProvider extends WebSocketProvider {\r\n    /** @internal */\r\n    constructor(config, wsConstructor) {\r\n        var _a;\r\n        // Normalize the API Key to a string.\r\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\r\n        const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'wss');\r\n        const protocol = `alchemy-sdk-${VERSION}`;\r\n        // Use the provided config URL override if it exists, otherwise use the created one.\r\n        const ws = new SturdyWebSocket((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {\r\n            wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()\r\n        });\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = EthersNetwork[alchemyNetwork];\r\n        super(ws, ethersNetwork);\r\n        this._events = [];\r\n        // In the case of a WebSocket reconnection, all subscriptions are lost and we\r\n        // create new ones to replace them, but we want to create the illusion that\r\n        // the original subscriptions persist. Thus, maintain a mapping from the\r\n        // \"virtual\" subscription ids which are visible to the consumer to the\r\n        // \"physical\" subscription ids of the actual connections. This terminology is\r\n        // borrowed from virtual and physical memory, which has a similar mapping.\r\n        /** @internal */\r\n        this.virtualSubscriptionsById = new Map();\r\n        /** @internal */\r\n        this.virtualIdsByPhysicalId = new Map();\r\n        /**\r\n         * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n         * messages. To allow backfilling, track all messages that are emitted.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleMessage = (event) => {\r\n            const message = JSON.parse(event.data);\r\n            if (!isSubscriptionEvent(message)) {\r\n                return;\r\n            }\r\n            const physicalId = message.params.subscription;\r\n            const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\r\n            if (!virtualId) {\r\n                return;\r\n            }\r\n            const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n            if (subscription.method !== 'eth_subscribe') {\r\n                return;\r\n            }\r\n            switch (subscription.params[0]) {\r\n                case 'newHeads': {\r\n                    const newHeadsSubscription = subscription;\r\n                    const newHeadsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = newHeadsSubscription;\r\n                    const { result } = newHeadsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToNewHeadsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    else {\r\n                        // Ethers subscription mapping will emit the event, just store it.\r\n                        this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'logs': {\r\n                    const logsSubscription = subscription;\r\n                    const logsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = logsSubscription;\r\n                    const { result } = logsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToLogsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (virtualId !== physicalId) {\r\n                        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    else {\r\n                        this.rememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        const { result } = message.params;\r\n                        this.emitEvent(virtualId, result);\r\n                    }\r\n            }\r\n        };\r\n        /**\r\n         * When the websocket connection reopens:\r\n         *\r\n         * 1. Resubscribe to all existing subscriptions and start backfilling\r\n         * 2. Restart heart beat.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleReopen = () => {\r\n            this.virtualIdsByPhysicalId.clear();\r\n            const { cancel, isCancelled } = makeCancelToken();\r\n            this.cancelBackfill = cancel;\r\n            for (const subscription of this.virtualSubscriptionsById.values()) {\r\n                void (() => __awaiter(this, void 0, void 0, function* () {\r\n                    try {\r\n                        yield this.resubscribeAndBackfill(isCancelled, subscription);\r\n                    }\r\n                    catch (error) {\r\n                        if (!isCancelled()) {\r\n                            console.error(`Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`, error);\r\n                        }\r\n                    }\r\n                }))();\r\n            }\r\n            this.startHeartbeat();\r\n        };\r\n        /**\r\n         * Cancels the heartbeat and any pending backfills being performed. This is\r\n         * called when the websocket connection goes down or is disconnected.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.stopHeartbeatAndBackfill = () => {\r\n            if (this.heartbeatIntervalId != null) {\r\n                clearInterval(this.heartbeatIntervalId);\r\n                this.heartbeatIntervalId = undefined;\r\n            }\r\n            this.cancelBackfill();\r\n        };\r\n        this.apiKey = apiKey;\r\n        // Start heartbeat and backfiller for the websocket connection.\r\n        this.backfiller = new WebsocketBackfiller(this);\r\n        this.addSocketListeners();\r\n        this.startHeartbeat();\r\n        this.cancelBackfill = noop;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in CustomNetworks) {\r\n            return CustomNetworks[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return getNetwork(network);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based subscriptions.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    on(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, false);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based\r\n     * subscriptions. Adds a listener to the triggered for only the next\r\n     * {@link eventName} event, after which it will be removed.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    once(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, true);\r\n    }\r\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName Event to unlisten to.\r\n     * @param listener The listener function to remove.\r\n     * @override\r\n     * @public\r\n     */\r\n    off(eventName, listener) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            return this._off(eventName, listener);\r\n        }\r\n        else {\r\n            return super.off(eventName, listener);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @override\r\n     * @public\r\n     */\r\n    removeAllListeners(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._removeAllListeners(eventName);\r\n        }\r\n        else {\r\n            return super.removeAllListeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listenerCount(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._listenerCount(eventName);\r\n        }\r\n        else {\r\n            return super.listenerCount(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listeners(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._listeners(eventName);\r\n        }\r\n        else {\r\n            return super.listeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the method in `BaseProvider` in order to properly format the\r\n     * Alchemy subscription events.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _addEventListener(eventName, listener, once) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            verifyAlchemyEventName(eventName);\r\n            const event = new EthersEvent(getAlchemyEventTag(eventName), listener, once);\r\n            this._events.push(event);\r\n            this._startEvent(event);\r\n            return this;\r\n        }\r\n        else {\r\n            return super._addEventListener(eventName, listener, once);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the `_startEvent()` method in ethers.js's\r\n     * {@link WebSocketProvider} to include additional alchemy methods.\r\n     *\r\n     * @param event\r\n     * @override\r\n     * @internal\r\n     */\r\n    _startEvent(event) {\r\n        // Check if the event type is a custom Alchemy subscription.\r\n        const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\r\n        if (customLogicTypes.includes(event.type)) {\r\n            this.customStartEvent(event);\r\n        }\r\n        else {\r\n            super._startEvent(event);\r\n        }\r\n    }\r\n    /**\r\n     * Overridden from ethers.js's {@link WebSocketProvider}\r\n     *\r\n     * Modified in order to add mappings for backfilling.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _subscribe(tag, param, processFunc, event) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let subIdPromise = this._subIds[tag];\r\n            // BEGIN MODIFIED CODE\r\n            const startingBlockNumber = yield this.getBlockNumber();\r\n            // END MODIFIED CODE\r\n            if (subIdPromise == null) {\r\n                subIdPromise = Promise.all(param).then(param => {\r\n                    return this.send('eth_subscribe', param);\r\n                });\r\n                this._subIds[tag] = subIdPromise;\r\n            }\r\n            const subId = yield subIdPromise;\r\n            // BEGIN MODIFIED CODE\r\n            const resolvedParams = yield Promise.all(param);\r\n            this.virtualSubscriptionsById.set(subId, {\r\n                event: event,\r\n                method: 'eth_subscribe',\r\n                params: resolvedParams,\r\n                startingBlockNumber,\r\n                virtualId: subId,\r\n                physicalId: subId,\r\n                sentEvents: [],\r\n                isBackfilling: false,\r\n                backfillBuffer: []\r\n            });\r\n            this.virtualIdsByPhysicalId.set(subId, subId);\r\n            // END MODIFIED CODE\r\n            this._subs[subId] = { tag, processFunc };\r\n        });\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    emit(eventName, ...args) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            let result = false;\r\n            const stopped = [];\r\n            // This line is the only modified line from the original method.\r\n            const eventTag = getAlchemyEventTag(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                setTimeout(() => {\r\n                    event.listener.apply(this, args);\r\n                }, 0);\r\n                result = true;\r\n                if (event.once) {\r\n                    stopped.push(event);\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n            stopped.forEach(event => {\r\n                this._stopEvent(event);\r\n            });\r\n            return result;\r\n        }\r\n        else {\r\n            return super.emit(eventName, ...args);\r\n        }\r\n    }\r\n    /** @internal */\r\n    sendBatch(parts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let nextId = 0;\r\n            const payload = parts.map(({ method, params }) => {\r\n                return {\r\n                    method,\r\n                    params,\r\n                    jsonrpc: '2.0',\r\n                    id: `alchemy-sdk:${nextId++}`\r\n                };\r\n            });\r\n            return this.sendBatchConcurrently(payload);\r\n        });\r\n    }\r\n    /** @override */\r\n    destroy() {\r\n        this.removeSocketListeners();\r\n        this.stopHeartbeatAndBackfill();\r\n        return super.destroy();\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\r\n     *\r\n     * This method is copied over directly in order to support Alchemy's\r\n     * subscription type by allowing the provider to properly stop Alchemy's\r\n     * subscription events.\r\n     *\r\n     * @internal\r\n     */\r\n    _stopEvent(event) {\r\n        let tag = event.tag;\r\n        // START MODIFIED CODE\r\n        if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\r\n            // There are remaining pending transaction listeners.\r\n            if (this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length) {\r\n                return;\r\n            }\r\n            // END MODIFIED CODE\r\n        }\r\n        else if (event.type === 'tx') {\r\n            // There are remaining transaction event listeners\r\n            if (this._events.filter(e => e.type === 'tx').length) {\r\n                return;\r\n            }\r\n            tag = 'tx';\r\n        }\r\n        else if (this.listenerCount(event.event)) {\r\n            // There are remaining event listeners\r\n            return;\r\n        }\r\n        const subId = this._subIds[tag];\r\n        if (!subId) {\r\n            return;\r\n        }\r\n        delete this._subIds[tag];\r\n        void subId.then(subId => {\r\n            if (!this._subs[subId]) {\r\n                return;\r\n            }\r\n            delete this._subs[subId];\r\n            void this.send('eth_unsubscribe', [subId]);\r\n        });\r\n    }\r\n    /** @internal */\r\n    addSocketListeners() {\r\n        this._websocket.addEventListener('message', this.handleMessage);\r\n        this._websocket.addEventListener('reopen', this.handleReopen);\r\n        this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /** @internal */\r\n    removeSocketListeners() {\r\n        this._websocket.removeEventListener('message', this.handleMessage);\r\n        this._websocket.removeEventListener('reopen', this.handleReopen);\r\n        this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /**\r\n     * Reopens the backfill based on\r\n     *\r\n     * @param isCancelled\r\n     * @param subscription\r\n     * @internal\r\n     */\r\n    resubscribeAndBackfill(isCancelled, subscription) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber } = subscription;\r\n            subscription.isBackfilling = true;\r\n            backfillBuffer.length = 0;\r\n            try {\r\n                const physicalId = yield this.send(method, params);\r\n                throwIfCancelled(isCancelled);\r\n                subscription.physicalId = physicalId;\r\n                this.virtualIdsByPhysicalId.set(physicalId, virtualId);\r\n                switch (params[0]) {\r\n                    case 'newHeads': {\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    case 'logs': {\r\n                        const filter = params[1] || {};\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitLogsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n            finally {\r\n                subscription.isBackfilling = false;\r\n                backfillBuffer.length = 0;\r\n            }\r\n        });\r\n    }\r\n    /** @internal */\r\n    emitNewHeadsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitLogsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n    }\r\n    /**\r\n     * Emits an event to consumers, but also remembers it in its subscriptions's\r\n     * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n     * and needs to be reconnected.\r\n     *\r\n     * @internal\r\n     */\r\n    emitAndRememberEvent(virtualId, result, getBlockNumber) {\r\n        this.rememberEvent(virtualId, result, getBlockNumber);\r\n        this.emitEvent(virtualId, result);\r\n    }\r\n    emitEvent(virtualId, result) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        this.emitGenericEvent(subscription, result);\r\n    }\r\n    /** @internal */\r\n    rememberEvent(virtualId, result, getBlockNumber) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        // Web3 modifies these event objects once we pass them on (changing hex\r\n        // numbers to numbers). We want the original event, so make a defensive\r\n        // copy.\r\n        addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitGenericEvent(subscription, result) {\r\n        const emitFunction = this.emitProcessFn(subscription.event);\r\n        emitFunction(result);\r\n    }\r\n    /**\r\n     * Starts a heartbeat that pings the websocket server periodically to ensure\r\n     * that the connection stays open.\r\n     *\r\n     * @internal\r\n     */\r\n    startHeartbeat() {\r\n        if (this.heartbeatIntervalId != null) {\r\n            return;\r\n        }\r\n        this.heartbeatIntervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                yield withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\r\n            }\r\n            catch (_a) {\r\n                this._websocket.reconnect();\r\n            }\r\n        }), HEARTBEAT_INTERVAL);\r\n    }\r\n    /**\r\n     * This method sends the batch concurrently as individual requests rather than\r\n     * as a batch, which was the original implementation. The original batch logic\r\n     * is preserved in this implementation in order for faster porting.\r\n     *\r\n     * @param payload\r\n     * @internal\r\n     */\r\n    // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\r\n    // TODO(errors): Use allSettled() once we have more error handling.\r\n    sendBatchConcurrently(payload) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return Promise.all(payload.map(req => this.send(req.method, req.params)));\r\n        });\r\n    }\r\n    /** @internal */\r\n    customStartEvent(event) {\r\n        if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\r\n            const { fromAddress, toAddress, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                AlchemySubscription.PENDING_TRANSACTIONS,\r\n                { fromAddress, toAddress, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\r\n            const { addresses, includeRemoved, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                AlchemySubscription.MINED_TRANSACTIONS,\r\n                { addresses, includeRemoved, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'block') {\r\n            void this._subscribe('block', ['newHeads'], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'filter') {\r\n            void this._subscribe(event.tag, ['logs', this._getFilter(event.filter)], this.emitProcessFn(event), event);\r\n        }\r\n    }\r\n    /** @internal */\r\n    emitProcessFn(event) {\r\n        switch (event.type) {\r\n            case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\r\n                return result => this.emit({\r\n                    method: AlchemySubscription.PENDING_TRANSACTIONS,\r\n                    fromAddress: event.fromAddress,\r\n                    toAddress: event.toAddress,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\r\n                return result => this.emit({\r\n                    method: AlchemySubscription.MINED_TRANSACTIONS,\r\n                    addresses: event.addresses,\r\n                    includeRemoved: event.includeRemoved,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case 'block':\r\n                return result => {\r\n                    const blockNumber = BigNumber.from(result.number).toNumber();\r\n                    this._emitted.block = blockNumber;\r\n                    this.emit('block', blockNumber);\r\n                };\r\n            case 'filter':\r\n                return result => {\r\n                    if (result.removed == null) {\r\n                        result.removed = false;\r\n                    }\r\n                    this.emit(event.filter, this.formatter.filterLog(result));\r\n                };\r\n            default:\r\n                throw new Error('Invalid event type to `emitProcessFn()`');\r\n        }\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.off()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _off(eventName, listener) {\r\n        if (listener == null) {\r\n            return this.removeAllListeners(eventName);\r\n        }\r\n        const stopped = [];\r\n        let found = false;\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        this._events = this._events.filter(event => {\r\n            if (event.tag !== eventTag || event.listener != listener) {\r\n                return true;\r\n            }\r\n            if (found) {\r\n                return true;\r\n            }\r\n            found = true;\r\n            stopped.push(event);\r\n            return false;\r\n        });\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _removeAllListeners(eventName) {\r\n        let stopped = [];\r\n        if (eventName == null) {\r\n            stopped = this._events;\r\n            this._events = [];\r\n        }\r\n        else {\r\n            const eventTag = getAlchemyEventTag(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                stopped.push(event);\r\n                return false;\r\n            });\r\n        }\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listenerCount(eventName) {\r\n        if (!eventName) {\r\n            return this._events.length;\r\n        }\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        return this._events.filter(event => {\r\n            return event.tag === eventTag;\r\n        }).length;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listeners(eventName) {\r\n        if (eventName == null) {\r\n            return this._events.map(event => event.listener);\r\n        }\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        return this._events\r\n            .filter(event => event.tag === eventTag)\r\n            .map(event => event.listener);\r\n    }\r\n}\r\nfunction getWebsocketConstructor() {\r\n    return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\r\n}\r\nfunction isNodeEnvironment() {\r\n    return (typeof process !== 'undefined' &&\r\n        process != null &&\r\n        process.versions != null &&\r\n        process.versions.node != null);\r\n}\r\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\r\nfunction makeCancelToken() {\r\n    let cancelled = false;\r\n    return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\r\n}\r\n// TODO(cleanup): replace with SDK's backoff implementation\r\nconst MIN_RETRY_DELAY = 1000;\r\nconst RETRY_BACKOFF_FACTOR = 2;\r\nconst MAX_RETRY_DELAY = 30000;\r\nfunction withBackoffRetries(f, retryCount, shouldRetry = () => true) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let nextWaitTime = 0;\r\n        let i = 0;\r\n        while (true) {\r\n            try {\r\n                return yield f();\r\n            }\r\n            catch (error) {\r\n                i++;\r\n                if (i >= retryCount || !shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                yield delay(nextWaitTime);\r\n                if (!shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                nextWaitTime =\r\n                    nextWaitTime === 0\r\n                        ? MIN_RETRY_DELAY\r\n                        : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction delay(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\nfunction withTimeout(promise, ms) {\r\n    return Promise.race([\r\n        promise,\r\n        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))\r\n    ]);\r\n}\r\nfunction getNewHeadsBlockNumber(event) {\r\n    return fromHex(event.number);\r\n}\r\nfunction getLogsBlockNumber(event) {\r\n    return fromHex(event.blockNumber);\r\n}\r\nfunction isResponse(message) {\r\n    return (Array.isArray(message) ||\r\n        (message.jsonrpc === '2.0' && message.id !== undefined));\r\n}\r\nfunction isSubscriptionEvent(message) {\r\n    return !isResponse(message);\r\n}\r\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\r\n}\r\nfunction addToLogsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\r\n}\r\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */\r\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\r\n    const currentBlockNumber = getBlockNumber(event);\r\n    // Find first index of an event recent enough to retain, then drop everything\r\n    // at a lower index.\r\n    const firstGoodIndex = pastEvents.findIndex(e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);\r\n    if (firstGoodIndex === -1) {\r\n        pastEvents.length = 0;\r\n    }\r\n    else {\r\n        pastEvents.splice(0, firstGoodIndex);\r\n    }\r\n    pastEvents.push(event);\r\n}\n\nexport { AlchemyWebSocketProvider };\n//# sourceMappingURL=alchemy-websocket-provider-a2f83072.js.map\n","import { AlchemyWebSocketProvider } from '../api/alchemy-websocket-provider';\nimport { fromHex, toHex } from '../api/util';\n\nexport interface BatchPart {\n  method: string;\n  params?: any;\n}\n\nexport interface NewHeadsEvent {\n  author: string;\n  difficulty: string;\n  extraData: string;\n  gasLimit: string;\n  gasUsed: string;\n  hash: string;\n  logsBloom: string;\n  miner: string;\n  mixHash: string;\n  nonce: string;\n  number: string;\n  parentHash: string;\n  receiptsRoot: string;\n  sealFields: string[];\n  sha3Uncles: string;\n  size: string;\n  stateRoot: string;\n  timestamp: string;\n  transactionsRoot: string;\n}\n\n/** The return type of eth_getBlocksByHash. */\nexport interface BlockHead extends NewHeadsEvent {\n  totalDifficulty: string;\n  transactions: any[];\n  uncles: string[];\n}\n\nexport interface LogsEvent {\n  address: string;\n  blockHash: string;\n  blockNumber: string;\n  data: string;\n  logIndex: string;\n  topics: string[];\n  transactionHash: string;\n  transactionIndex: string;\n  removed?: boolean;\n}\n\nexport interface LogsSubscriptionFilter {\n  address?: string | string[];\n  topics?: Array<string | string[] | null>;\n}\n\nexport interface GetLogsOptions extends LogsSubscriptionFilter {\n  fromBlock?: string;\n  toBlock?: string;\n}\n\ninterface CommonAncestor {\n  blockNumber: number;\n  logIndex: number;\n}\n\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n\n/**\n * The WebsocketBackfiller fetches events that were sent since a provided block\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\n * events that were transmitted while the websocket connection was down.\n *\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\n *\n * @internal\n */\nexport class WebsocketBackfiller {\n  // TODO: Use HTTP provider to do backfill.\n  private maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n  constructor(private readonly provider: AlchemyWebSocketProvider) {}\n\n  /**\n   * Runs backfill for `newHeads` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param previousHeads Previous head requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   * @returns A list of `newHeads` events that were sent since the last backfill.\n   */\n  async getNewHeadsBackfill(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n    fromBlockNumber: number\n  ): Promise<NewHeadsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous heads to fetch, return new heads since\n    // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n    if (previousHeads.length === 0) {\n      return this.getHeadEventsInRange(\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted event is too far back in the past, there's no need\n    // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n    // new heads.\n    const lastSeenBlockNumber = fromHex(\n      previousHeads[previousHeads.length - 1].number\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber <= minBlockNumber) {\n      return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n    }\n\n    // To capture all `newHeads` events, return all head events from the last\n    // seen block number to current + any of the previous heads that were re-orged.\n    const reorgHeads: NewHeadsEvent[] = await this.getReorgHeads(\n      isCancelled,\n      previousHeads\n    );\n    throwIfCancelled(isCancelled);\n    const intermediateHeads: NewHeadsEvent[] = await this.getHeadEventsInRange(\n      lastSeenBlockNumber + 1,\n      toBlockNumber + 1\n    );\n    throwIfCancelled(isCancelled);\n    return [...reorgHeads, ...intermediateHeads];\n  }\n\n  /**\n   * Runs backfill for `logs` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param filter The filter object that accompanies a logs subscription.\n   * @param previousLogs Previous log requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   */\n  async getLogsBackfill(\n    isCancelled: () => boolean,\n    filter: LogsSubscriptionFilter,\n    previousLogs: LogsEvent[],\n    fromBlockNumber: number\n  ): Promise<LogsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous logs to fetch, return new logs since\n    // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n    if (previousLogs.length === 0) {\n      return this.getLogsInRange(\n        filter,\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted log is too far back in the past, there's no need\n    // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n    // worth of logs.\n    const lastSeenBlockNumber = fromHex(\n      previousLogs[previousLogs.length - 1].blockNumber\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n    }\n\n    // Return all log events that have happened along with log events that have\n    // been removed due to a chain reorg.\n    const commonAncestor = await this.getCommonAncestor(\n      isCancelled,\n      previousLogs\n    );\n    throwIfCancelled(isCancelled);\n\n    // All previous logs with a block number greater than the common ancestor\n    // were part of a re-org, so mark them as such.\n    const removedLogs = previousLogs\n      .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\n      .map(log => ({ ...log, removed: true }));\n\n    // If no common ancestor was found, start backfill from the oldest log's\n    // block number.\n    const fromBlockInclusive =\n      commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\n        ? fromHex(previousLogs[0].blockNumber)\n        : commonAncestor.blockNumber;\n    let addedLogs = await this.getLogsInRange(\n      filter,\n      fromBlockInclusive,\n      toBlockNumber + 1\n    );\n\n    // De-dupe any logs that were already emitted.\n    addedLogs = addedLogs.filter(\n      log =>\n        log &&\n        (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\n          fromHex(log.logIndex) > commonAncestor.logIndex)\n    );\n\n    throwIfCancelled(isCancelled);\n    return [...removedLogs, ...addedLogs];\n  }\n\n  /**\n   * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\n   *\n   * @internal\n   */\n  setMaxBackfillBlock(newMax: number): void {\n    this.maxBackfillBlocks = newMax;\n  }\n\n  /**\n   * Gets the current block number as a number.\n   *\n   * @private\n   */\n  private async getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await this.provider.send('eth_blockNumber');\n    return fromHex(blockNumberHex);\n  }\n\n  /**\n   * Gets all `newHead` events in the provided range. Note that the returned\n   * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\n   * that were part of a re-org.\n   *\n   * @private\n   */\n  private async getHeadEventsInRange(\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<NewHeadsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const batchParts: BatchPart[] = [];\n    for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n      batchParts.push({\n        method: 'eth_getBlockByNumber',\n        params: [toHex(i), false]\n      });\n    }\n\n    // TODO: handle errors\n    const blockHeads = await this.provider.sendBatch(batchParts);\n    return blockHeads.map(toNewHeadsEvent);\n  }\n\n  /**\n   * Returns all heads that were part of a reorg event.\n   *\n   * @private\n   */\n  private async getReorgHeads(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[]\n  ): Promise<NewHeadsEvent[]> {\n    const result: NewHeadsEvent[] = [];\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    for (let i = previousHeads.length - 1; i >= 0; i--) {\n      const oldEvent = previousHeads[i];\n      const blockHead = await this.getBlockByNumber(fromHex(oldEvent.number));\n      throwIfCancelled(isCancelled);\n\n      // If the hashes match, then current head in the iteration was not re-orged.\n      if (oldEvent.hash === blockHead.hash) {\n        break;\n      }\n\n      result.push(toNewHeadsEvent(blockHead));\n    }\n    return result.reverse();\n  }\n\n  /**\n   * Simple wrapper around `eth_getBlockByNumber` that returns the complete\n   * block information for the provided block number.\n   *\n   * @private\n   */\n  private async getBlockByNumber(blockNumber: number): Promise<BlockHead> {\n    return this.provider.send('eth_getBlockByNumber', [\n      toHex(blockNumber),\n      false\n    ]);\n  }\n\n  /**\n   * Given a list of previous log events, finds the common block number from the\n   * logs that matches the block head.\n   *\n   * This can be used to identify which logs are part of a re-org.\n   *\n   * Returns 1 less than the oldest log's block number if no common ancestor was found.\n   *\n   * @private\n   */\n  private async getCommonAncestor(\n    isCancelled: () => boolean,\n    previousLogs: LogsEvent[]\n  ): Promise<CommonAncestor> {\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    let blockHead = await this.getBlockByNumber(\n      fromHex(previousLogs[previousLogs.length - 1].blockNumber)\n    );\n    throwIfCancelled(isCancelled);\n    for (let i = previousLogs.length - 1; i >= 0; i--) {\n      const oldLog = previousLogs[i];\n\n      // Ensure that updated blocks are fetched every time the log's block number\n      // changes.\n      if (oldLog.blockNumber !== blockHead.number) {\n        blockHead = await this.getBlockByNumber(fromHex(oldLog.blockNumber));\n      }\n\n      // Since logs are ordered in ascending order, the first log that matches\n      // the hash should be the largest logIndex.\n      if (oldLog.blockHash === blockHead.hash) {\n        return {\n          blockNumber: fromHex(oldLog.blockNumber),\n          logIndex: fromHex(oldLog.logIndex)\n        };\n      }\n    }\n    return {\n      blockNumber: Number.NEGATIVE_INFINITY,\n      logIndex: Number.NEGATIVE_INFINITY\n    };\n  }\n\n  /**\n   * Gets all `logs` events in the provided range. Note that the returned logs\n   * do not include removed logs.\n   *\n   * @private\n   */ private async getLogsInRange(\n    filter: LogsSubscriptionFilter,\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<LogsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const rangeFilter: GetLogsOptions = {\n      ...filter,\n      fromBlock: toHex(fromBlockInclusive),\n      toBlock: toHex(toBlockExclusive - 1)\n    };\n    return this.provider.send('eth_getLogs', [rangeFilter]);\n  }\n}\n\nfunction toNewHeadsEvent(head: BlockHead): NewHeadsEvent {\n  const result: NewHeadsEvent & Partial<BlockHead> = { ...head };\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\n\nexport function dedupeNewHeads(events: NewHeadsEvent[]): NewHeadsEvent[] {\n  return dedupe(events, event => event.hash);\n}\n\nexport function dedupeLogs(events: LogsEvent[]): LogsEvent[] {\n  return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\n}\n\nfunction dedupe<T>(items: T[], getKey: (item: T) => any): T[] {\n  const keysSeen: Set<any> = new Set();\n  const result: T[] = [];\n  items.forEach(item => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\n\nconst CANCELLED = new Error('Cancelled');\nexport function throwIfCancelled(isCancelled: () => boolean): void {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\n","import SturdyWebSocket from 'sturdy-websocket';\n\nimport { Listener } from '@ethersproject/abstract-provider';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport {\n  Networkish,\n  getNetwork as getNetworkFromEthers\n} from '@ethersproject/networks';\nimport { Network as NetworkFromEthers } from '@ethersproject/networks/lib/types';\nimport {\n  CommunityResourcable,\n  WebSocketProvider\n} from '@ethersproject/providers';\n\nimport {\n  EthersEvent,\n  getAlchemyEventTag,\n  isAlchemyEvent,\n  verifyAlchemyEventName\n} from '../internal/ethers-event';\nimport {\n  ALCHEMY_EVENT_TYPES,\n  ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE,\n  ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  SingleOrBatchResponse,\n  SubscriptionEvent,\n  WebSocketMessage\n} from '../internal/internal-types';\nimport {\n  BatchPart,\n  LogsEvent,\n  LogsSubscriptionFilter,\n  NewHeadsEvent,\n  WebsocketBackfiller,\n  dedupeLogs,\n  dedupeNewHeads,\n  throwIfCancelled\n} from '../internal/websocket-backfiller';\nimport { AlchemyEventType, AlchemySubscription } from '../types/types';\nimport {\n  CustomNetworks,\n  DEFAULT_ALCHEMY_API_KEY,\n  EthersNetwork,\n  noop\n} from '../util/const';\nimport { VERSION } from '../version';\nimport { AlchemyConfig } from './alchemy-config';\nimport { AlchemyProvider } from './alchemy-provider';\nimport { fromHex } from './util';\n\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\n\n/**\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\n *\n * Do not call this constructor directly. Instead, instantiate an instance of\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\n *\n * @public\n */\nexport class AlchemyWebSocketProvider\n  extends WebSocketProvider\n  implements CommunityResourcable\n{\n  _events: Array<EthersEvent> = [];\n  readonly apiKey: string;\n\n  // In the case of a WebSocket reconnection, all subscriptions are lost and we\n  // create new ones to replace them, but we want to create the illusion that\n  // the original subscriptions persist. Thus, maintain a mapping from the\n  // \"virtual\" subscription ids which are visible to the consumer to the\n  // \"physical\" subscription ids of the actual connections. This terminology is\n  // borrowed from virtual and physical memory, which has a similar mapping.\n  /** @internal */\n  private readonly virtualSubscriptionsById: Map<string, VirtualSubscription> =\n    new Map();\n  /** @internal */\n  private readonly virtualIdsByPhysicalId: Map<string, string> = new Map();\n  /** @internal */\n  private readonly backfiller: WebsocketBackfiller;\n  /** @internal */\n  private heartbeatIntervalId?: NodeJS.Timeout;\n  /** @internal */\n  private cancelBackfill: () => void;\n\n  /** @internal */\n  constructor(config: AlchemyConfig, wsConstructor?: any) {\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'wss'\n    );\n\n    const protocol = `alchemy-sdk-${VERSION}`;\n\n    // Use the provided config URL override if it exists, otherwise use the created one.\n    const ws = new SturdyWebSocket(config.url ?? connection.url, protocol, {\n      wsConstructor: wsConstructor ?? getWebsocketConstructor()\n    });\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(ws as any, ethersNetwork);\n    this.apiKey = apiKey;\n\n    // Start heartbeat and backfiller for the websocket connection.\n    this.backfiller = new WebsocketBackfiller(this);\n    this.addSocketListeners();\n    this.startHeartbeat();\n    this.cancelBackfill = noop;\n  }\n\n  /**\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\n   *\n   * This override allows the SDK to set the provider's network to values not\n   * yet supported by ethers.js.\n   *\n   * @internal\n   * @override\n   */\n  static getNetwork(network: Networkish): NetworkFromEthers {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetworkFromEthers(network);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based subscriptions.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  on(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, false);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based\n   * subscriptions. Adds a listener to the triggered for only the next\n   * {@link eventName} event, after which it will be removed.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  once(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, true);\n  }\n\n  /**\n   * Removes the provided {@link listener} for the {@link eventName} event. If no\n   * listener is provided, all listeners for the event will be removed.\n   *\n   * @param eventName Event to unlisten to.\n   * @param listener The listener function to remove.\n   * @override\n   * @public\n   */\n  off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (isAlchemyEvent(eventName)) {\n      return this._off(eventName, listener);\n    } else {\n      return super.off(eventName, listener);\n    }\n  }\n\n  /**\n   * Remove all listeners for the provided {@link eventName} event. If no event\n   * is provided, all events and their listeners are removed.\n   *\n   * @param eventName The event to remove all listeners for.\n   * @override\n   * @public\n   */\n  removeAllListeners(eventName?: AlchemyEventType): this {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._removeAllListeners(eventName);\n    } else {\n      return super.removeAllListeners(eventName);\n    }\n  }\n\n  /**\n   * Returns the number of listeners for the provided {@link eventName} event. If\n   * no event is provided, the total number of listeners for all events is returned.\n   *\n   * @param eventName The event to get the number of listeners for.\n   * @public\n   * @override\n   */\n  listenerCount(eventName?: AlchemyEventType): number {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listenerCount(eventName);\n    } else {\n      return super.listenerCount(eventName);\n    }\n  }\n\n  /**\n   * Returns an array of listeners for the provided {@link eventName} event. If\n   * no event is provided, all listeners will be included.\n   *\n   * @param eventName The event to get the listeners for.\n   * @public\n   * @override\n   */\n  listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listeners(eventName);\n    } else {\n      return super.listeners(eventName);\n    }\n  }\n\n  /**\n   * Overrides the method in `BaseProvider` in order to properly format the\n   * Alchemy subscription events.\n   *\n   * @internal\n   * @override\n   */\n  _addEventListener(\n    eventName: AlchemyEventType,\n    listener: Listener,\n    once: boolean\n  ): this {\n    if (isAlchemyEvent(eventName)) {\n      verifyAlchemyEventName(eventName);\n      const event = new EthersEvent(\n        getAlchemyEventTag(eventName),\n        listener,\n        once\n      );\n      this._events.push(event);\n      this._startEvent(event);\n      return this;\n    } else {\n      return super._addEventListener(eventName, listener, once);\n    }\n  }\n\n  /**\n   * Overrides the `_startEvent()` method in ethers.js's\n   * {@link WebSocketProvider} to include additional alchemy methods.\n   *\n   * @param event\n   * @override\n   * @internal\n   */\n  _startEvent(event: EthersEvent): void {\n    // Check if the event type is a custom Alchemy subscription.\n    const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\n    if (customLogicTypes.includes(event.type)) {\n      this.customStartEvent(event);\n    } else {\n      super._startEvent(event);\n    }\n  }\n\n  /**\n   * Overridden from ethers.js's {@link WebSocketProvider}\n   *\n   * Modified in order to add mappings for backfilling.\n   *\n   * @internal\n   * @override\n   */\n  async _subscribe(\n    tag: string,\n    param: Array<any>,\n    processFunc: (result: any) => void,\n    event?: EthersEvent\n  ): Promise<void> {\n    let subIdPromise = this._subIds[tag];\n\n    // BEGIN MODIFIED CODE\n    const startingBlockNumber = await this.getBlockNumber();\n    // END MODIFIED CODE\n\n    if (subIdPromise == null) {\n      subIdPromise = Promise.all(param).then(param => {\n        return this.send('eth_subscribe', param);\n      });\n      this._subIds[tag] = subIdPromise;\n    }\n    const subId = await subIdPromise;\n\n    // BEGIN MODIFIED CODE\n    const resolvedParams = await Promise.all(param);\n    this.virtualSubscriptionsById.set(subId, {\n      event: event!,\n      method: 'eth_subscribe',\n      params: resolvedParams,\n      startingBlockNumber,\n      virtualId: subId,\n      physicalId: subId,\n      sentEvents: [],\n      isBackfilling: false,\n      backfillBuffer: []\n    });\n    this.virtualIdsByPhysicalId.set(subId, subId);\n\n    // END MODIFIED CODE\n\n    this._subs[subId] = { tag, processFunc };\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @internal\n   * @override\n   */\n  emit(eventName: AlchemyEventType, ...args: Array<any>): boolean {\n    if (isAlchemyEvent(eventName)) {\n      let result = false;\n\n      const stopped: Array<EthersEvent> = [];\n\n      // This line is the only modified line from the original method.\n      const eventTag = getAlchemyEventTag(eventName);\n\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n\n        setTimeout(() => {\n          event.listener.apply(this, args);\n        }, 0);\n\n        result = true;\n\n        if (event.once) {\n          stopped.push(event);\n          return false;\n        }\n\n        return true;\n      });\n\n      stopped.forEach(event => {\n        this._stopEvent(event);\n      });\n\n      return result;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n\n  /** @internal */\n  async sendBatch(parts: BatchPart[]): Promise<any[]> {\n    let nextId = 0;\n    const payload: JsonRpcRequest[] = parts.map(({ method, params }) => {\n      return {\n        method,\n        params,\n        jsonrpc: '2.0',\n        id: `alchemy-sdk:${nextId++}`\n      };\n    });\n\n    return this.sendBatchConcurrently(payload);\n  }\n\n  /** @override */\n  destroy(): Promise<void> {\n    this.removeSocketListeners();\n    this.stopHeartbeatAndBackfill();\n    return super.destroy();\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\n   *\n   * This method is copied over directly in order to support Alchemy's\n   * subscription type by allowing the provider to properly stop Alchemy's\n   * subscription events.\n   *\n   * @internal\n   */\n  _stopEvent(event: EthersEvent): void {\n    let tag = event.tag;\n\n    // START MODIFIED CODE\n    if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\n      // There are remaining pending transaction listeners.\n      if (\n        this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length\n      ) {\n        return;\n      }\n      // END MODIFIED CODE\n    } else if (event.type === 'tx') {\n      // There are remaining transaction event listeners\n      if (this._events.filter(e => e.type === 'tx').length) {\n        return;\n      }\n      tag = 'tx';\n    } else if (this.listenerCount(event.event)) {\n      // There are remaining event listeners\n      return;\n    }\n\n    const subId = this._subIds[tag];\n    if (!subId) {\n      return;\n    }\n\n    delete this._subIds[tag];\n    void subId.then(subId => {\n      if (!this._subs[subId]) {\n        return;\n      }\n      delete this._subs[subId];\n      void this.send('eth_unsubscribe', [subId]);\n    });\n  }\n\n  /** @internal */\n  private addSocketListeners(): void {\n    this._websocket.addEventListener('message', this.handleMessage);\n    this._websocket.addEventListener('reopen', this.handleReopen);\n    this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /** @internal */\n  private removeSocketListeners(): void {\n    this._websocket.removeEventListener('message', this.handleMessage);\n    this._websocket.removeEventListener('reopen', this.handleReopen);\n    this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /**\n   * The underlying ethers {@link WebSocketProvider} already handles and emits\n   * messages. To allow backfilling, track all messages that are emitted.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleMessage = (event: MessageEvent): void => {\n    const message: WebSocketMessage = JSON.parse(event.data);\n    if (!isSubscriptionEvent(message)) {\n      return;\n    }\n    const physicalId = message.params.subscription;\n    const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n    if (!virtualId) {\n      return;\n    }\n    const subscription = this.virtualSubscriptionsById.get(virtualId)!;\n    if (subscription.method !== 'eth_subscribe') {\n      return;\n    }\n\n    switch (subscription.params[0]) {\n      case 'newHeads': {\n        const newHeadsSubscription = subscription as NewHeadsSubscription;\n        const newHeadsMessage = message as SubscriptionEvent<NewHeadsEvent>;\n        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n        const { result } = newHeadsMessage.params;\n        if (isBackfilling) {\n          addToNewHeadsEventsBuffer(backfillBuffer, result);\n        } else if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        } else {\n          // Ethers subscription mapping will emit the event, just store it.\n          this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        }\n        break;\n      }\n      case 'logs': {\n        const logsSubscription = subscription as LogsSubscription;\n        const logsMessage = message as SubscriptionEvent<LogsEvent>;\n        const { isBackfilling, backfillBuffer } = logsSubscription;\n        const { result } = logsMessage.params;\n        if (isBackfilling) {\n          addToLogsEventsBuffer(backfillBuffer, result);\n        } else if (virtualId !== physicalId) {\n          this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n        } else {\n          this.rememberEvent(virtualId, result, getLogsBlockNumber);\n        }\n        break;\n      }\n      default:\n        if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          const { result } = (message as SubscriptionEvent<unknown>).params;\n          this.emitEvent(virtualId, result);\n        }\n    }\n  };\n\n  /**\n   * When the websocket connection reopens:\n   *\n   * 1. Resubscribe to all existing subscriptions and start backfilling\n   * 2. Restart heart beat.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleReopen = () => {\n    this.virtualIdsByPhysicalId.clear();\n    const { cancel, isCancelled } = makeCancelToken();\n    this.cancelBackfill = cancel;\n    for (const subscription of this.virtualSubscriptionsById.values()) {\n      void (async () => {\n        try {\n          await this.resubscribeAndBackfill(isCancelled, subscription);\n        } catch (error) {\n          if (!isCancelled()) {\n            console.error(\n              `Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`,\n              error\n            );\n          }\n        }\n      })();\n    }\n    this.startHeartbeat();\n  };\n\n  /**\n   * Reopens the backfill based on\n   *\n   * @param isCancelled\n   * @param subscription\n   * @internal\n   */\n  private async resubscribeAndBackfill(\n    isCancelled: () => boolean,\n    subscription: VirtualSubscription\n  ): Promise<void> {\n    const {\n      virtualId,\n      method,\n      params,\n      sentEvents,\n      backfillBuffer,\n      startingBlockNumber\n    } = subscription;\n    subscription.isBackfilling = true;\n    backfillBuffer.length = 0;\n    try {\n      const physicalId = await this.send(method, params);\n      throwIfCancelled(isCancelled);\n      subscription.physicalId = physicalId;\n      this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n      switch (params[0]) {\n        case 'newHeads': {\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getNewHeadsBackfill(\n                  isCancelled,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\n          break;\n        }\n        case 'logs': {\n          const filter: LogsSubscriptionFilter = params[1] || {};\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getLogsBackfill(\n                  isCancelled,\n                  filter,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitLogsEvent(virtualId, event));\n          break;\n        }\n        default:\n          break;\n      }\n    } finally {\n      subscription.isBackfilling = false;\n      backfillBuffer.length = 0;\n    }\n  }\n\n  /**\n   * Cancels the heartbeat and any pending backfills being performed. This is\n   * called when the websocket connection goes down or is disconnected.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private stopHeartbeatAndBackfill = () => {\n    if (this.heartbeatIntervalId != null) {\n      clearInterval(this.heartbeatIntervalId);\n      this.heartbeatIntervalId = undefined;\n    }\n    this.cancelBackfill();\n  };\n\n  /** @internal */\n  private emitNewHeadsEvent(virtualId: string, result: NewHeadsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n\n  /** @internal */\n  private emitLogsEvent(virtualId: string, result: LogsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   *\n   * @internal\n   */\n  private emitAndRememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    this.rememberEvent(virtualId, result, getBlockNumber);\n    this.emitEvent(virtualId, result);\n  }\n\n  private emitEvent<T>(virtualId: string, result: T): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    this.emitGenericEvent(subscription, result);\n  }\n\n  /** @internal */\n  private rememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(\n      subscription.sentEvents,\n      { ...result },\n      getBlockNumber\n    );\n  }\n\n  /** @internal */\n  private emitGenericEvent(\n    subscription: VirtualSubscription,\n    result: any\n  ): void {\n    const emitFunction = this.emitProcessFn(subscription.event);\n    emitFunction(result);\n  }\n\n  /**\n   * Starts a heartbeat that pings the websocket server periodically to ensure\n   * that the connection stays open.\n   *\n   * @internal\n   */\n  private startHeartbeat(): void {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(async () => {\n      try {\n        await withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\n      } catch {\n        this._websocket.reconnect();\n      }\n    }, HEARTBEAT_INTERVAL);\n  }\n\n  /**\n   * This method sends the batch concurrently as individual requests rather than\n   * as a batch, which was the original implementation. The original batch logic\n   * is preserved in this implementation in order for faster porting.\n   *\n   * @param payload\n   * @internal\n   */\n  // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n  // TODO(errors): Use allSettled() once we have more error handling.\n  private async sendBatchConcurrently(\n    payload: JsonRpcRequest[]\n  ): Promise<unknown[]> {\n    return Promise.all(payload.map(req => this.send(req.method, req.params)));\n  }\n\n  /** @internal */\n  private customStartEvent(event: EthersEvent): void {\n    if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      const { fromAddress, toAddress, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          AlchemySubscription.PENDING_TRANSACTIONS,\n          { fromAddress, toAddress, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\n      const { addresses, includeRemoved, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          AlchemySubscription.MINED_TRANSACTIONS,\n          { addresses, includeRemoved, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'block') {\n      void this._subscribe(\n        'block',\n        ['newHeads'],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'filter') {\n      void this._subscribe(\n        event.tag,\n        ['logs', this._getFilter(event.filter)],\n        this.emitProcessFn(event),\n        event\n      );\n    }\n  }\n\n  /** @internal */\n  private emitProcessFn(event: EthersEvent): (result: any) => void {\n    switch (event.type) {\n      case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\n        return result =>\n          this.emit(\n            {\n              method: AlchemySubscription.PENDING_TRANSACTIONS,\n              fromAddress: event.fromAddress,\n              toAddress: event.toAddress,\n              hashesOnly: event.hashesOnly\n            },\n            result\n          );\n      case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\n        return result =>\n          this.emit(\n            {\n              method: AlchemySubscription.MINED_TRANSACTIONS,\n              addresses: event.addresses,\n              includeRemoved: event.includeRemoved,\n              hashesOnly: event.hashesOnly\n            },\n            result\n          );\n      case 'block':\n        return result => {\n          const blockNumber = BigNumber.from(result.number).toNumber();\n          this._emitted.block = blockNumber;\n          this.emit('block', blockNumber);\n        };\n      case 'filter':\n        return result => {\n          if (result.removed == null) {\n            result.removed = false;\n          }\n          this.emit(event.filter, this.formatter.filterLog(result));\n        };\n      default:\n        throw new Error('Invalid event type to `emitProcessFn()`');\n    }\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.off()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (listener == null) {\n      return this.removeAllListeners(eventName);\n    }\n\n    const stopped: Array<EthersEvent> = [];\n\n    let found = false;\n    const eventTag = getAlchemyEventTag(eventName);\n    this._events = this._events.filter(event => {\n      if (event.tag !== eventTag || event.listener != listener) {\n        return true;\n      }\n      if (found) {\n        return true;\n      }\n      found = true;\n      stopped.push(event);\n      return false;\n    });\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _removeAllListeners(eventName: AlchemyEventType): this {\n    let stopped: Array<EthersEvent> = [];\n    if (eventName == null) {\n      stopped = this._events;\n\n      this._events = [];\n    } else {\n      const eventTag = getAlchemyEventTag(eventName);\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n        stopped.push(event);\n        return false;\n      });\n    }\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listenerCount(eventName?: AlchemyEventType): number {\n    if (!eventName) {\n      return this._events.length;\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events.filter(event => {\n      return event.tag === eventTag;\n    }).length;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName == null) {\n      return this._events.map(event => event.listener);\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events\n      .filter(event => event.tag === eventTag)\n      .map(event => event.listener);\n  }\n}\n\nfunction getWebsocketConstructor(): any {\n  return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\n}\n\nfunction isNodeEnvironment(): boolean {\n  return (\n    typeof process !== 'undefined' &&\n    process != null &&\n    process.versions != null &&\n    process.versions.node != null\n  );\n}\n\n/** @internal */\ninterface CancelToken {\n  cancel(): void;\n  isCancelled(): boolean;\n}\n\ninterface VirtualSubscription {\n  event: EthersEvent;\n  virtualId: string;\n  physicalId: string;\n  method: string;\n  params: any[];\n  isBackfilling: boolean;\n  startingBlockNumber: number;\n  sentEvents: any[];\n  backfillBuffer: any[];\n}\n\ninterface NewHeadsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['newHeads'];\n  isBackfilling: boolean;\n  sentEvents: NewHeadsEvent[];\n  backfillBuffer: NewHeadsEvent[];\n}\n\ninterface LogsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['logs', LogsSubscriptionFilter?];\n  isBackfilling: boolean;\n  sentEvents: LogsEvent[];\n  backfillBuffer: LogsEvent[];\n}\n\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken(): CancelToken {\n  let cancelled = false;\n  return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\n}\n\n// TODO(cleanup): replace with SDK's backoff implementation\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\n\nasync function withBackoffRetries<T>(\n  f: () => Promise<T>,\n  retryCount: number,\n  shouldRetry: (error: unknown) => boolean = () => true\n): Promise<T> {\n  let nextWaitTime = 0;\n  let i = 0;\n  while (true) {\n    try {\n      return await f();\n    } catch (error) {\n      i++;\n      if (i >= retryCount || !shouldRetry(error)) {\n        throw error;\n      }\n      await delay(nextWaitTime);\n      if (!shouldRetry(error)) {\n        throw error;\n      }\n      nextWaitTime =\n        nextWaitTime === 0\n          ? MIN_RETRY_DELAY\n          : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n    }\n  }\n}\n\nfunction delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), ms)\n    )\n  ]);\n}\n\nfunction getNewHeadsBlockNumber(event: NewHeadsEvent): number {\n  return fromHex(event.number);\n}\n\nfunction getLogsBlockNumber(event: LogsEvent): number {\n  return fromHex(event.blockNumber);\n}\n\nfunction isResponse(\n  message: WebSocketMessage\n): message is SingleOrBatchResponse {\n  return (\n    Array.isArray(message) ||\n    (message.jsonrpc === '2.0' && (message as JsonRpcResponse).id !== undefined)\n  );\n}\n\nfunction isSubscriptionEvent(\n  message: WebSocketMessage\n): message is SubscriptionEvent {\n  return !isResponse(message);\n}\n\nfunction addToNewHeadsEventsBuffer(\n  pastEvents: NewHeadsEvent[],\n  event: NewHeadsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\n\nfunction addToLogsEventsBuffer(\n  pastEvents: LogsEvent[],\n  event: LogsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n\n/**\n * Adds a new event to an array of events, evicting any events which are so old\n * that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer<T>(\n  pastEvents: T[],\n  event: T,\n  getBlockNumber: (event: T) => number\n): void {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(\n    e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT\n  );\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar SturdyWebSocket = /** @class */ (function () {\n    function SturdyWebSocket(url, protocolsOrOptions, options) {\n        if (options === void 0) { options = {}; }\n        this.url = url;\n        this.onclose = null;\n        this.onerror = null;\n        this.onmessage = null;\n        this.onopen = null;\n        this.ondown = null;\n        this.onreopen = null;\n        this.CONNECTING = SturdyWebSocket.CONNECTING;\n        this.OPEN = SturdyWebSocket.OPEN;\n        this.CLOSING = SturdyWebSocket.CLOSING;\n        this.CLOSED = SturdyWebSocket.CLOSED;\n        this.hasBeenOpened = false;\n        this.isClosed = false;\n        this.messageBuffer = [];\n        this.nextRetryTime = 0;\n        this.reconnectCount = 0;\n        this.lastKnownExtensions = \"\";\n        this.lastKnownProtocol = \"\";\n        this.listeners = {};\n        if (protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)) {\n            this.protocols = protocolsOrOptions;\n        }\n        else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            }\n            else {\n                throw new Error(\"WebSocket not present in global scope and no \" +\n                    \"wsConstructor option was provided.\");\n            }\n        }\n        this.openNewWebSocket();\n    }\n    Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n        get: function () {\n            return this.binaryTypeInternal || \"blob\";\n        },\n        set: function (binaryType) {\n            this.binaryTypeInternal = binaryType;\n            if (this.ws) {\n                this.ws.binaryType = binaryType;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n        get: function () {\n            var sum = this.ws ? this.ws.bufferedAmount : 0;\n            var hasUnknownAmount = false;\n            this.messageBuffer.forEach(function (data) {\n                var byteLength = getDataByteLength(data);\n                if (byteLength != null) {\n                    sum += byteLength;\n                }\n                else {\n                    hasUnknownAmount = true;\n                }\n            });\n            if (hasUnknownAmount) {\n                this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\");\n            }\n            return sum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n        get: function () {\n            return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n        get: function () {\n            return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n        get: function () {\n            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SturdyWebSocket.prototype.close = function (code, reason) {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    };\n    SturdyWebSocket.prototype.send = function (data) {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        }\n        else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        }\n        else {\n            this.messageBuffer.push(data);\n        }\n    };\n    SturdyWebSocket.prototype.reconnect = function () {\n        if (this.isClosed) {\n            throw new Error(\"Cannot call reconnect() on socket which is permanently closed.\");\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    };\n    SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    };\n    SturdyWebSocket.prototype.dispatchEvent = function (event) {\n        return this.dispatchEventOfType(event.type, event);\n    };\n    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(function (l) { return l !== listener; });\n        }\n    };\n    SturdyWebSocket.prototype.openNewWebSocket = function () {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;\n        this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n        var ws = new wsConstructor(this.url, this.protocols);\n        ws.onclose = function (event) { return _this.handleClose(event); };\n        ws.onerror = function (event) { return _this.handleError(event); };\n        ws.onmessage = function (event) { return _this.handleMessage(event); };\n        ws.onopen = function (event) { return _this.handleOpen(event); };\n        this.connectTimeoutId = setTimeout(function () {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            _this.clearConnectTimeout();\n            _this.disposeSocket();\n            _this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    };\n    SturdyWebSocket.prototype.handleOpen = function (event) {\n        var _this = this;\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        var allClearResetTime = this.options.allClearResetTime;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        }\n        else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        }\n        else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(function (message) { return _this.send(message); });\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(function () {\n            _this.clearAllClearTimeout();\n            _this.nextRetryTime = 0;\n            _this.reconnectCount = 0;\n            var openTime = (allClearResetTime / 1000) | 0;\n            _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" +\n                \" retry time and count.\");\n        }, allClearResetTime);\n    };\n    SturdyWebSocket.prototype.handleMessage = function (event) {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    };\n    SturdyWebSocket.prototype.handleClose = function (event) {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n            return;\n        }\n        var willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n        }\n        else {\n            willReconnect.then(function (willReconnectResolved) {\n                if (_this.isClosed) {\n                    return;\n                }\n                _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n            });\n        }\n    };\n    SturdyWebSocket.prototype.handleError = function (event) {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    };\n    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n        if (willReconnect) {\n            this.reestablishConnection();\n        }\n        else {\n            this.stopReconnecting(event, denialReason);\n        }\n    };\n    SturdyWebSocket.prototype.reestablishConnection = function () {\n        var _this = this;\n        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;\n        this.reconnectCount++;\n        var retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n        setTimeout(function () { return _this.openNewWebSocket(); }, retryTime);\n        var retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n    };\n    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    };\n    SturdyWebSocket.prototype.shutdown = function () {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    };\n    SturdyWebSocket.prototype.disposeSocket = function (closeCode, reason) {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    };\n    SturdyWebSocket.prototype.clearAllTimeouts = function () {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    };\n    SturdyWebSocket.prototype.clearConnectTimeout = function () {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n        var _this = this;\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(function (listener) { return _this.callListener(listener, event); });\n        }\n        return !event || !event.defaultPrevented;\n    };\n    SturdyWebSocket.prototype.callListener = function (listener, event) {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        }\n        else {\n            listener.handleEvent.call(this, event);\n        }\n    };\n    SturdyWebSocket.prototype.debugLog = function (message) {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    };\n    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n        var maxReconnectAttempts = this.options.maxReconnectAttempts;\n        return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n    };\n    SturdyWebSocket.DEFAULT_OPTIONS = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: function () { return true; },\n        wsConstructor: undefined,\n    };\n    SturdyWebSocket.CONNECTING = 0;\n    SturdyWebSocket.OPEN = 1;\n    SturdyWebSocket.CLOSING = 2;\n    SturdyWebSocket.CLOSED = 3;\n    return SturdyWebSocket;\n}());\nexports.default = SturdyWebSocket;\nfunction applyDefaultOptions(options) {\n    var result = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(function (key) {\n        var value = options[key];\n        result[key] =\n            value === undefined\n                ? SturdyWebSocket.DEFAULT_OPTIONS[key]\n                : value;\n    });\n    return result;\n}\nfunction getDataByteLength(data) {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    }\n    else if (data instanceof Blob) {\n        return data.size;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction pluralize(s, n) {\n    return n === 1 ? s : s + \"s\";\n}\nfunction noop() {\n    // Nothing.\n}\n//# sourceMappingURL=index.js.map","export interface Options {\n    allClearResetTime?: number;\n    connectTimeout?: number;\n    debug?: boolean;\n    minReconnectDelay?: number;\n    maxReconnectDelay?: number;\n    maxReconnectAttempts?: number;\n    reconnectBackoffFactor?: number;\n    wsConstructor?: new (url: string, protocols?: string | string[]) => any;\n    shouldReconnect?(closeEvent: CloseEvent): boolean | Promise<boolean>;\n}\n\ninterface SturdyWebSocketEventMap extends WebSocketEventMap {\n    down: CloseEvent;\n    reopen: Event;\n}\n\ntype WebSocketListener<K extends keyof SturdyWebSocketEventMap> = (\n    this: WebSocket,\n    event: SturdyWebSocketEventMap[K],\n) => any;\n\ntype WebSocketListeners = {\n    [K in keyof SturdyWebSocketEventMap]?: Array<WebSocketListener<K>>;\n} & {\n    [key: string]: EventListenerOrEventListenerObject[];\n};\n\nconst SHOULD_RECONNECT_FALSE_MESSAGE =\n    \"Provided shouldReconnect() returned false. Closing permanently.\";\nconst SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE =\n    \"Provided shouldReconnect() resolved to false. Closing permanently.\";\n\nexport default class SturdyWebSocket implements WebSocket {\n    public static readonly DEFAULT_OPTIONS: Required<Options> = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: () => true,\n        wsConstructor: undefined!,\n    };\n\n    public static readonly CONNECTING = 0;\n    public static readonly OPEN = 1;\n    public static readonly CLOSING = 2;\n    public static readonly CLOSED = 3;\n\n    public onclose: ((event: CloseEvent) => void) | null = null;\n    public onerror: ((event: Event) => void) | null = null;\n    public onmessage: ((event: MessageEvent) => void) | null = null;\n    public onopen: ((event: Event) => void) | null = null;\n    public ondown: ((event: CloseEvent | undefined) => void) | null = null;\n    public onreopen: ((event: Event) => void) | null = null;\n    public readonly CONNECTING = SturdyWebSocket.CONNECTING;\n    public readonly OPEN = SturdyWebSocket.OPEN;\n    public readonly CLOSING = SturdyWebSocket.CLOSING;\n    public readonly CLOSED = SturdyWebSocket.CLOSED;\n\n    private readonly protocols?: string | string[];\n    private readonly options: Required<Options>;\n    private ws?: WebSocket;\n    private hasBeenOpened = false;\n    private isClosed = false;\n    private messageBuffer: any[] = [];\n    private nextRetryTime: number = 0;\n    private reconnectCount = 0;\n    private allClearTimeoutId?: any;\n    private connectTimeoutId?: any;\n    private binaryTypeInternal?: BinaryType;\n    private lastKnownExtensions = \"\";\n    private lastKnownProtocol = \"\";\n    private readonly listeners: WebSocketListeners = {};\n\n    constructor(url: string, options?: Options);\n    constructor(\n        url: string,\n        protocols: string | string[] | undefined,\n        options?: Options,\n    );\n    constructor(\n        public readonly url: string,\n        protocolsOrOptions?: string | string[] | Options,\n        options: Options = {},\n    ) {\n        if (\n            protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)\n        ) {\n            this.protocols = protocolsOrOptions;\n        } else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            } else {\n                throw new Error(\n                    \"WebSocket not present in global scope and no \" +\n                        \"wsConstructor option was provided.\",\n                );\n            }\n        }\n        this.openNewWebSocket();\n    }\n\n    public get binaryType(): BinaryType {\n        return this.binaryTypeInternal || \"blob\";\n    }\n\n    public set binaryType(binaryType: BinaryType) {\n        this.binaryTypeInternal = binaryType;\n        if (this.ws) {\n            this.ws.binaryType = binaryType;\n        }\n    }\n\n    public get bufferedAmount(): number {\n        let sum = this.ws ? this.ws.bufferedAmount : 0;\n        let hasUnknownAmount = false;\n        this.messageBuffer.forEach(data => {\n            const byteLength = getDataByteLength(data);\n            if (byteLength != null) {\n                sum += byteLength;\n            } else {\n                hasUnknownAmount = true;\n            }\n        });\n        if (hasUnknownAmount) {\n            this.debugLog(\n                \"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\",\n            );\n        }\n        return sum;\n    }\n\n    public get extensions(): string {\n        return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n    }\n\n    public get protocol(): string {\n        return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n    }\n\n    public get readyState(): number {\n        return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n    }\n\n    public close(code?: number, reason?: string): void {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    }\n\n    public send(data: any): void {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        } else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        } else {\n            this.messageBuffer.push(data);\n        }\n    }\n\n    public reconnect(): void {\n        if (this.isClosed) {\n            throw new Error(\n                \"Cannot call reconnect() on socket which is permanently closed.\",\n            );\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    }\n\n    public addEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    }\n\n    public dispatchEvent(event: Event): boolean {\n        return this.dispatchEventOfType(event.type, event);\n    }\n\n    public removeEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(\n                l => l !== listener,\n            );\n        }\n    }\n\n    private openNewWebSocket(): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { connectTimeout, wsConstructor } = this.options;\n        this.debugLog(`Opening new WebSocket to ${this.url}.`);\n        const ws: WebSocket = new wsConstructor(this.url, this.protocols);\n        ws.onclose = event => this.handleClose(event);\n        ws.onerror = event => this.handleError(event);\n        ws.onmessage = event => this.handleMessage(event);\n        ws.onopen = event => this.handleOpen(event);\n        this.connectTimeoutId = setTimeout(() => {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            this.clearConnectTimeout();\n            this.disposeSocket();\n            this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    }\n\n    private handleOpen(event: Event): void {\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        const { allClearResetTime } = this.options;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        } else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        } else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(message => this.send(message));\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(() => {\n            this.clearAllClearTimeout();\n            this.nextRetryTime = 0;\n            this.reconnectCount = 0;\n            const openTime = (allClearResetTime / 1000) | 0;\n            this.debugLog(\n                `WebSocket remained open for ${openTime} seconds. Resetting` +\n                    \" retry time and count.\",\n            );\n        }, allClearResetTime);\n    }\n\n    private handleMessage(event: MessageEvent): void {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    }\n\n    private handleClose(event: CloseEvent | undefined): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { maxReconnectAttempts, shouldReconnect } = this.options;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(\n                event,\n                this.getTooManyFailedReconnectsMessage(),\n            );\n            return;\n        }\n        const willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(\n                willReconnect,\n                event,\n                SHOULD_RECONNECT_FALSE_MESSAGE,\n            );\n        } else {\n            willReconnect.then(willReconnectResolved => {\n                if (this.isClosed) {\n                    return;\n                }\n                this.handleWillReconnect(\n                    willReconnectResolved,\n                    event,\n                    SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE,\n                );\n            });\n        }\n    }\n\n    private handleError(event: Event): void {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    }\n\n    private handleWillReconnect(\n        willReconnect: boolean,\n        event: CloseEvent | undefined,\n        denialReason: string,\n    ): void {\n        if (willReconnect) {\n            this.reestablishConnection();\n        } else {\n            this.stopReconnecting(event, denialReason);\n        }\n    }\n\n    private reestablishConnection(): void {\n        const {\n            minReconnectDelay,\n            maxReconnectDelay,\n            reconnectBackoffFactor,\n        } = this.options;\n        this.reconnectCount++;\n        const retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(\n            minReconnectDelay,\n            Math.min(\n                this.nextRetryTime * reconnectBackoffFactor,\n                maxReconnectDelay,\n            ),\n        );\n        setTimeout(() => this.openNewWebSocket(), retryTime);\n        const retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\n            `WebSocket was closed. Re-opening in ${retryTimeSeconds} seconds.`,\n        );\n    }\n\n    private stopReconnecting(\n        event: CloseEvent | undefined,\n        debugReason: string,\n    ): void {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    }\n\n    private shutdown(): void {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    }\n\n    private disposeSocket(closeCode?: number, reason?: string): void {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    }\n\n    private clearAllTimeouts(): void {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    }\n\n    private clearConnectTimeout(): void {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    }\n\n    private clearAllClearTimeout(): void {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    }\n\n    private dispatchEventOfType(type: string, event: any): boolean {\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(listener => this.callListener(listener, event));\n        }\n        return !event || !(event as Event).defaultPrevented;\n    }\n\n    private callListener(\n        listener: EventListenerOrEventListenerObject,\n        event: Event,\n    ): void {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        } else {\n            listener.handleEvent.call(this, event);\n        }\n    }\n\n    private debugLog(message: string): void {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    }\n\n    private getTooManyFailedReconnectsMessage(): string {\n        const { maxReconnectAttempts } = this.options;\n        return `Failed to reconnect after ${maxReconnectAttempts} ${pluralize(\n            \"attempt\",\n            maxReconnectAttempts,\n        )}. Closing permanently.`;\n    }\n}\n\nfunction applyDefaultOptions(options: Options): Required<Options> {\n    const result: any = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(key => {\n        const value = (options as any)[key];\n        result[key] =\n            value === undefined\n                ? (SturdyWebSocket.DEFAULT_OPTIONS as any)[key]\n                : value;\n    });\n    return result;\n}\n\nfunction getDataByteLength(data: any): number | undefined {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    } else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    } else if (data instanceof Blob) {\n        return data.size;\n    } else {\n        return undefined;\n    }\n}\n\nfunction pluralize(s: string, n: number): string {\n    return n === 1 ? s : `${s}s`;\n}\n\nfunction noop(): void {\n    // Nothing.\n}\n"],"names":["parcelRequire","parcelRegister","$parcel$global","globalThis","register","module","exports","Object","defineProperty","get","$ad2c604ba644dcfb$export$f6c13301c7b76371","set","s","enumerable","configurable","$07xSV","$5R2ui","$3HDBd","$kYIxw","$i7Wzi","$bq21X","$ibaza","$ad2c604ba644dcfb$var$WebsocketBackfiller","constructor","provider","maxBackfillBlocks","getNewHeadsBackfill","isCancelled","previousHeads","fromBlockNumber","_","$ad2c604ba644dcfb$var$throwIfCancelled","toBlockNumber","getBlockNumber","length","getHeadEventsInRange","Math","max","lastSeenBlockNumber","f","number","minBlockNumber","reorgHeads","getReorgHeads","intermediateHeads","getLogsBackfill","filter","previousLogs","getLogsInRange","blockNumber","commonAncestor","getCommonAncestor","removedLogs","log","map","assign","removed","fromBlockInclusive","Number","NEGATIVE_INFINITY","addedLogs","logIndex","setMaxBackfillBlock","newMax","blockNumberHex","send","toBlockExclusive","batchParts","i","push","method","params","t","blockHeads","sendBatch","$ad2c604ba644dcfb$var$toNewHeadsEvent","result","oldEvent","blockHead","getBlockByNumber","hash","reverse","oldLog","blockHash","rangeFilter","fromBlock","toBlock","head","totalDifficulty","transactions","uncles","$ad2c604ba644dcfb$var$dedupe","items","getKey","keysSeen","Set","forEach","item","key","has","add","$ad2c604ba644dcfb$var$CANCELLED","Error","WebSocketProvider","config","wsConstructor","_a","apiKey","AlchemyProvider","getApiKey","alchemyNetwork","getAlchemyNetwork","network","connection","getAlchemyConnectionInfo","protocol","V","ws","a","__esModule","default","url","$ad2c604ba644dcfb$var$isNodeEnvironment","versions","node","w3cwebsocket","WebSocket","ethersNetwork","E","_events","virtualSubscriptionsById","Map","virtualIdsByPhysicalId","handleMessage","event","message","JSON","parse","data","Array","isArray","jsonrpc","undefined","id","physicalId","subscription","virtualId","isBackfilling","backfillBuffer","newHeadsMessage","$ad2c604ba644dcfb$var$addToPastEventsBuffer","$ad2c604ba644dcfb$var$getNewHeadsBlockNumber","emitAndRememberEvent","rememberEvent","logsMessage","$ad2c604ba644dcfb$var$getLogsBlockNumber","emitEvent","handleReopen","cancelled","clear","cancel","cancelBackfill","values","resubscribeAndBackfill","error","console","startHeartbeat","stopHeartbeatAndBackfill","heartbeatIntervalId","clearInterval","backfiller","addSocketListeners","n","getNetwork","C","on","eventName","listener","_addEventListener","once","off","_off","removeAllListeners","_removeAllListeners","listenerCount","_listenerCount","listeners","_listeners","v","c","e","_startEvent","customLogicTypes","A","includes","type","customStartEvent","_subscribe","tag","param","processFunc","subIdPromise","_subIds","startingBlockNumber","Promise","all","then","subId","resolvedParams","sentEvents","_subs","emit","args","stopped","eventTag","setTimeout","apply","_stopEvent","parts","nextId","payload","sendBatchConcurrently","destroy","removeSocketListeners","isCommunityResource","D","_websocket","addEventListener","removeEventListener","events","backfillEvents","$ad2c604ba644dcfb$var$withBackoffRetries","$ad2c604ba644dcfb$var$withTimeout","emitNewHeadsEvent","emitLogsEvent","emitGenericEvent","emitFunction","emitProcessFn","setInterval","reconnect","req","h","fromAddress","toAddress","hashesOnly","j","PENDING_TRANSACTIONS","k","addresses","includeRemoved","MINED_TRANSACTIONS","_getFilter","BigNumber","from","toNumber","_emitted","block","formatter","filterLog","found","retryCount","shouldRetry","nextWaitTime","$ad2c604ba644dcfb$var$delay","ms","resolve","min","$ad2c604ba644dcfb$var$RETRY_BACKOFF_FACTOR","promise","race","reject","pastEvents","currentBlockNumber","firstGoodIndex","findIndex","splice","value","$4433d4fff50a186a$var$SturdyWebSocket","SturdyWebSocket","protocolsOrOptions","options","onclose","onerror","onmessage","onopen","ondown","onreopen","CONNECTING","OPEN","CLOSING","CLOSED","hasBeenOpened","isClosed","messageBuffer","nextRetryTime","reconnectCount","lastKnownExtensions","lastKnownProtocol","protocols","keys","DEFAULT_OPTIONS","openNewWebSocket","prototype","binaryTypeInternal","binaryType","sum","bufferedAmount","hasUnknownAmount","byteLength","ArrayBuffer","Blob","size","debugLog","extensions","close","code","reason","disposeSocket","shutdown","readyState","handleClose","dispatchEvent","dispatchEventOfType","l","_this","connectTimeout","handleError","handleOpen","connectTimeoutId","clearConnectTimeout","allClearResetTime","allClearTimeoutId","clearAllClearTimeout","maxReconnectAttempts","shouldReconnect","stopReconnecting","getTooManyFailedReconnectsMessage","willReconnect","handleWillReconnect","willReconnectResolved","denialReason","reestablishConnection","minReconnectDelay","maxReconnectDelay","reconnectBackoffFactor","retryTime","debugReason","clearAllTimeouts","closeCode","$4433d4fff50a186a$var$noop","clearTimeout","slice","callListener","defaultPrevented","call","handleEvent","debug","POSITIVE_INFINITY","getNetworkFromEthers"],"version":3,"file":"alchemy-websocket-provider-a2f83072.b413acec.js.map"}